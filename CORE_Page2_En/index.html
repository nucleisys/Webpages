
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>1.Introduction of the Bumblebee Processor Core Â· gitbook tutorial</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-disqus/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-advanced-emoji/emoji-website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-chapter-fold/chapter-fold.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-tbfed-pagefooter/footer.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="./" />
    
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./#1.md">
            
                    
                    1.Introduction of the Bumblebee Processor Core
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="./">
            
                <a href="./#1-1">
            
                    
                    1.1 Bumblebee Core Feature List
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="./">
            
                <a href="./#1-2">
            
                    
                    1.2 Bumblebee Core Instruction set and architecture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="./">
            
                <a href="./#1-3">
            
                    
                    1.3 Bumblebee Core Hierarchy Diagram
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="./">
            
                <a href="./#2">
            
                    
                    2.Bumblebee to the function of the Bumblebee Core
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="./">
            
                <a href="./#2-1">
            
                    
                    2.1 Introduction to the Bumblebee Core Clock Domain
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="./">
            
                <a href="./#2-2">
            
                    
                    2.2 Introduction to the Bumblebee Core Power Domain
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="./">
            
                <a href="./#2-3">
            
                    
                    2.3 The Memory Map of the Bumblebee Core
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="./">
            
                <a href="./#2-4">
            
                    
                    2.4 The Privilege Modes of the Bumblebee Core
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="./">
            
                <a href="./#2-5">
            
                    
                    2.5 Memory Resources of the Bumblebee Core
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.6" data-path="./">
            
                <a href="./#2-6">
            
                    
                    2.6 Private Periphearals of the Bumblebee Core
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="./">
            
                <a href="./#2-7">
            
                    
                    2.7 Physical Memory Protection of the Bumblebee Core
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.8" data-path="./">
            
                <a href="./#2-8">
            
                    
                    2.8 Debugging Mechanism of the Bumblebee Core
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.9" data-path="./">
            
                <a href="./#2-9">
            
                    
                    2.9 Interrupt and Exception Mechanism of the Bumblebee Core
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.10" data-path="./">
            
                <a href="./#2-10">
            
                    
                    2.10 NMI Mechanism of the Bumblebee Core
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.11" data-path="./">
            
                <a href="./#2-11">
            
                    
                    2.11 CSRs of the Bumblebee Core
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.12" data-path="./">
            
                <a href="./#2-12">
            
                    
                    2.12 Perfomance Monitor's Counters of the Bumblebee Core
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13" data-path="./">
            
                <a href="./#2-13">
            
                    
                    2.13 Timer Unit of the Bumblebee Core
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.13.1" data-path="./">
            
                <a href="./#2-13-1">
            
                    
                    2.13.1 Time Behavior in Debug Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.13.2" data-path="./">
            
                <a href="./#2-13-2">
            
                    
                    2.13.2 Time Behavior in Normal Mode
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.14" data-path="./">
            
                <a href="./#2-14">
            
                    
                    2.14 Low-Power Mechanism of the Bumblebee Core
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.14.1" data-path="./">
            
                <a href="./#2-14-1">
            
                    
                    2.14.1 Clock Control Entering Sleep Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.14.2" data-path="./">
            
                <a href="./#2-14-2">
            
                    
                    2.14.2 Clock Conttol of Exiting the Sleep Mode
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="./">
            
                <a href="./#3">
            
                    
                    3. Introduction of Interfaces of the Bumblebee core
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="./">
            
                <a href="./#3-1">
            
                    
                    3.1 Introduction of Interfaces of Bumblebee core
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >1.Introduction of the Bumblebee Processor Core</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <p>For more comprehensive information, please visit <a href="http://www.riscv-mcu.com" target="_blank">www.riscv-mcu.com</a></p>
<p>The pdf document is maintained in <a href="https://github.com/nucleisys/Bumblebee_Core_Doc" target="_blank">https://github.com/nucleisys/Bumblebee_Core_Doc</a></p>
<h1 id="1-introduction-of-the-bumblebee-processor-core">1. <strong>Introduction of the Bumblebee Processor Core</strong><div id="1"></div></h1>
<p>   The Bumblebee Processor Core, or Bumblebee core for short&#xFF0C;is a commercial RISC-V processor core customized by Nuclei System Technology and Gigadevice for general-purpose MCU products for IoT or other ultra-low-power applications. It is dedicated to MCU products of model GD32VF103.</p>
<p>Note&#xFF1A;The Bumblebee core used for this MCU is jointly developed by Nuclei System Technology and Andes Technology. Nuclei System Technology provides authorization services and technical support.</p>
<p>&#x200B;    At present, Nuclei System Technology can authorize fully domestically controllable N200 series ultra-low power commercial processor core IPs, as well as other multiple series (300/600/900 series) 32-bit or 64-bit high-performance embedded processor core IPs, and provide customers with processor IP customization services.</p>
<h2 id="11bumblebee-core-feature-list">1.1.<strong>Bumblebee Core Feature List</strong><div id="1-1"></div></h2>
<p>The Bumblebee core has the following features:</p>
<ul>
<li><p>CPU Core</p>
<ul>
<li>2-stage variable pipeline architecture, using state-of-the-art processor architecture to deliver the highest degree of performance efficiency and lowest cost. </li>
<li>Simple dynamic branch predictor.</li>
<li>The instruction fetch unit (IFU) can prefetch the following two instructions to mask the instruction memory access latency.</li>
<li>Support Machine Mode and User Mode.</li>
</ul>
</li>
<li><p>Supported Instruction Set Architecture (ISA)</p>
<ul>
<li>The Bumblebee core is a 32-bit RISC-V-based processor, supporting a combination of RISCV 32IMAC instruction subsets.</li>
<li>Hardware supports misaligned memory access operations (Load/Store instructions)</li>
</ul>
</li>
<li><p>Bus Interface</p>
<ul>
<li>Supports 32-bit wide standard AHB-Lite system bus interface for accessing external instruction and data.</li>
<li>Supports 32-bit wide Instruction Local Memory (ILM) bus interface (supports standard AHB-Lite or SRAM interface protocol) for private instruction local memory. </li>
<li>Supports 32-bit wide Data Local Memory (DLM) bus interface (supports standard AHB-Lite or SRAM interface protocol) for private data local memory. </li>
<li>Supports 32-bit wide Private Peripheral Interface (PPI) bus interface, and supports standard APB interface protocol for private peripherals. </li>
</ul>
</li>
<li><p>Debugging System</p>
<ul>
<li>Supports standard JTAG interface.</li>
<li>Supports standard RISC-V debugging systems.</li>
<li>Supports up to 4 Hardware Breakpoints.</li>
<li>Supports mature interactive debugging tools.</li>
</ul>
</li>
<li><p>Low-Power Management</p>
<ul>
<li>Supports WFI&#xFF08;Wait For Interrupt&#xFF09;and WFE&#xFF08;Wait For Event&#xFF09;to enter sleep mode.</li>
<li>Supports two-level sleep modes: shallow sleep mode and deep sleep mode.</li>
</ul>
</li>
<li><p>Core-Private Timer Unit</p>
</li>
<li><p>64-bit real-time timer, supporting the generation of the timer interrupt defined by the RISC-V standard. </p>
</li>
<li><p>Enhanced Core Level Interrupt Controller (ECLIC)</p>
<ul>
<li>Supports the RISC-V architecturally defined software, timer and external interrupts.</li>
<li>Supports dozens of external interrupt sources. For the supported number and allocation of interrupts, please refer to the datasheet of the specific MCU chip.</li>
<li>Supports up to 16 interrupt levels and priorities, and supports software dynamic programmable modification of values of interrupt levels and priorities.</li>
<li>Supports interrupt preemption based on interrupt levels.</li>
<li>Supports fast vectored interrupt processing.</li>
<li>Supports fast interrupt tail-chaining mechanism</li>
</ul>
</li>
<li><p>Supports NMI&#xFF08;Non-Maskable Interrupt&#xFF09;&#x3002;</p>
</li>
<li><p>Software development tools&#xFF1A;</p>
<ul>
<li>The Bumblebee core supports the RISC-V standard compilation tool chain and Integrated Development Environment (IDE) on Linux/Windows systems.</li>
</ul>
</li>
</ul>
<h2 id="12-bumblebee-core-instruction-set-and-architecture"><strong>1.2.</strong> <strong>Bumblebee Core Instruction Set and Architecture</strong><div id="1-2"></div></h2>
<p>Please refer to the Bumblebee Processor Core Instruction Set Architecture Manual for details about the instruction sets supported and architectures of the core.</p>
<h2 id="13-bumblebee-core-hierarchy-diagram"><strong>1.3.</strong> <strong>Bumblebee Core Hierarchy Diagram</strong><div id="1-3"></div></h2>
<p>&#x200B;               The top level of the Bumblebee core is shown in Figure 1-1. The structure of the Bumblebee core contains the following points: </p>
<ul>
<li>The Core is the top-level of the whole processor</li>
<li>The uCore is located under the Core hierarchy and is the main part of the processor core.</li>
<li>In addition to the uCore, the following components are included in the Core&#x201D;<ul>
<li>DEBUG&#xFF1A;handle the JTAG interface and related debugging features.</li>
<li>ECLIC&#xFF1A;the Enhanced Core Level Interrupt Controller</li>
<li>TIMER&#xFF1A;the timer unit.</li>
<li>LM Ctrl&#xFF1A;the control unit of external ILM and DLM interface.</li>
<li>BIU&#xFF1A;the control unit of external PPI interface and MEM interface.</li>
<li>Misc Ctrl&#xFF1A;the control unit of other components.</li>
</ul>
</li>
</ul>
<p><img src="1.assets/&#x56FE;&#x7247;1-1.png" alt="img"> 
&#x200B;                                <strong> <center>Figure 1-1 Top-level of the Bumblebee Core</center></strong></p>
<h1 id="2-introduction-to-the-function-of-the-bumblebee-core">2. <strong>Introduction to the Function of the Bumblebee Core</strong><div id="2"></div></h1>
<h2 id="21-introduction-to-the-bumblebee-core-clock-domain"><strong>2.1.</strong> <strong>Introduction to the Bumblebee Core Clock Domain</strong><div id="2-1"></div></h2>
<pre><code> The clock domains of the Bumblebee core are shown in Figure 2-1. The entire processor is divided into two asynchronous clock domains:
</code></pre><ul>
<li><p>The core clock domain includes the core_clk and core_clk_aon, which drive most of the functional logic of the processor core. Note:</p>
<ul>
<li>core_clk and core_clk_aon have the same frequency and phases as they are clocks from the same clock source.</li>
<li>core_clk is the main working clock that drives the main function logic inside the processor core and is clock-gated at the system level.</li>
<li>core_clk_aon is an always-on clock that drives the always-on logic in the core, including the ECLIC, the Timer, and the Debugger. Please refer to the Bumblebee Processor Core Instruction Set Architecture Manual for details about the ECLIC and the Timer.</li>
</ul>
</li>
<li><p>JTAG clock domain includes the jtag_TCK, which drives the corresponding logic of JTAG debugging system.</p>
<p>The above two clock domains are asynchronous, so asynchronous cross-clock domain processing has been implemented in the processor core. </p>
</li>
</ul>
<p><img src="1.assets/&#x56FE;&#x7247;2-1.png" alt="img"> </p>
<p><strong><center>Figure2-1  Clock domains of the Bumblebee Core</center></strong></p>
<h2 id="22-introduction-to-the-bumblebee-core-power-domain">2.2. <strong>Introduction to the Bumblebee Core Power Domain</strong><div id="2-2"></div></h2>
<p>The Bumblebee Core does not have a power domain inside. The SoC system integrator can divide the power domain and perform cross-power domain processing according to the Bumblebee Core hierarchy.</p>
<h2 id="23-the-memory-map-of-the-bumblebee-core">2.3. <strong>The Memory Map of the Bumblebee Core</strong><div id="2-3"></div></h2>
<p>For the memory map of the Bumblebee Core, please refer to the datasheet of the specific MCU chip.</p>
<h2 id="24-the-privilege-modes-of-the-bumblebee-core">2.4. <strong>The Privilege Modes of the Bumblebee Core</strong><div id="2-4"></div></h2>
<p>The Bumblebee Core supports two privilege modes: Machine mode and User mode. For the detailed information about privilege modes, please refer to the Bumblebee Processor Core Instruction Set Architecture Manual.</p>
<h2 id="25-memory-resources-of-the-bumblebee-core">2.5. <strong>Memory resources of the Bumblebee Core</strong><div id="2-5"></div></h2>
<p>Bumblebee core supports the following memory resources:</p>
<ul>
<li><p>ILM&#xFF1A;</p>
<ul>
<li>The Bumblebee Core supports Instruction Local Memory (ILM) access via a proprietary AHB-Lite Bus or SRAM interface if an ILM interface is configured.</li>
<li>The size of the ILM is configurable. The ILM interface has separate address space, and the user can configure a specific base address for it. Please see Section 2.3 for details.</li>
<li>The ILM is implemented by the SoC system integrator and can generally be an on-chip SRAM or Flash for storing instructions. If the AHB-Lite interface is implemented, to achieve optimal performance, the ILM should be implemented to support the AHB protocol and return instructions at the next cycle after receiving the read request.</li>
</ul>
</li>
<li><p>DLM&#xFF1A;</p>
<ul>
<li><p>The Bumblebee Core supports Data Local Memory (DLM) access via a proprietary AHB-Lite Bus or SRAM interface if a DLM interface is configured.</p>
</li>
<li><p>The size of the DLM is configurable. The DLM interface has separate address space, and the user can configure a specific base address for it. Please see Section 2.3 for details.</p>
</li>
<li><p>The DLM is implemented by the SoC system integrator and can generally be an on-chip SRAM or Flash for storing instructions. If the AHB-Lite interface is implemented, to achieve optimal performance, the DLM should be implemented to support the AHB protocol and return instructions at the next cycle after receiving the read request.</p>
</li>
</ul>
</li>
</ul>
<h2 id="26-private-peripherals-of-the-bumblebee-core">2.6. <strong>Private Peripherals of the Bumblebee Core</strong><div id="2-6"></div></h2>
<p>As shown in Figure 1-1, under the Core hierarchy of the Bumblebee Core, in addition to the uCore, the following private peripherals are included:  </p>
<ul>
<li>DEBUG&#xFF1A;handle the JTAG interface and related debugging features.</li>
<li>ECLIC&#xFF1A;the Enhanced Core-Level Interrupt Controller.</li>
<li>TIMER&#xFF1A;the private TIMER unit.</li>
</ul>
<p>The above devices are private to the processor core and are accessed using memory address. See Section 2.3 for the details of their specific address space allocation. </p>
<h2 id="27-physical-memory-protection-of-the-bumblebee-core">2.7. <strong>Physical Memory Protection of the Bumblebee Core</strong><div id="2-7"></div></h2>
<p>&#x200B;            Bumblebee Core is a low-power core designed for microcontrollers, it does not support the Memory Management Unit, so all the address access operations are using physical addresses. In order to perform memory access protection and isolation according to memory physical address of different devices and execution privilege mode, the RISC-V standard architecture defines a physical memory protection mechanism: Physical Memory Protection (PMP) unit.</p>
<p>Note: the Bumblebee Core does not support PMP unit.</p>
<h2 id="28-debugging-mechanism-of-the-bumblebee-core">2.8. <strong>Debugging Mechanism of the Bumblebee Core</strong><div id="2-8"></div></h2>
<p>&#x200B;          bee Core supports standard JTAG debugging interface, and the interactive debugging tool GDB. Note:</p>
<ul>
<li>The Bumblebee Core supports up to 4 hardware breakpoints. Hardware breakpoints are primarily used to set breakpoints to read-only memory space such as FLASH.</li>
<li>The Bumblebee Core defines an input signal i_dbg_stop, which can be controlled by the external drive:</li>
<li>If the value of the i_dbg_stop signal is 1, the debug mode of the processor is off.</li>
<li>If the value of the i_dbg_stop signal is 0, the debug mode of the processor is working properly.</li>
</ul>
<h2 id="29-interrupt-and-exception-mechanism-of-the-bumblebee-core">2.9. <strong>Interrupt and Exception Mechanism of the Bumblebee Core</strong><div id="2-9"></div></h2>
<p>&#x200B;                 For a detailed description of the Bumblebee Core&apos;s interrupt and exception mechanisms, please refer to the Bumblebee Processor Core Instruction Set Architecture Manual.</p>
<h2 id="210-nmi-mechanism-of-the-bumblebee-core">2.10. <strong>NMI Mechanism of the Bumblebee Core</strong><div id="2-10"></div></h2>
<p>NMI (Non-Maskable Interrupt) is a special input signal of the processor, often used to indicate system-level emergency errors (such as external hardware failures, etc.) After encountering the NMI, the processor should abort execution of the current program immediately and process the NMI error instead. For a detailed description of the NMI mechanism of the Bumblebee Core, please refer to the Bumblebee Processor Core Instruction Set Architecture Manual.</p>
<h2 id="211-csrs-of-the-bumblebee-core">2.11. <strong>CSRs of the Bumblebee Core</strong><div id="2-11"></div></h2>
<p>&#x200B;            Some control and status registers (CSRs) are defined in the RISC-V architecture to configure or record the status of execution. CSR registers are registers internal to the processor core that uses their proprietary 12-bit encoding space to access. Please see the Bumblebee Processor Core Instruction Set Architecture Manual for more details.</p>
<h2 id="212-perfomance-monitors-counters-of-the-bumblebee-core">2.12. <strong>Perfomance Monitor&#x2019;s Counters of the Bumblebee Core</strong><div id="2-12"></div></h2>
<p>&#x200B;              The RISC-V   architecture defines the following two performance counters:</p>
<ul>
<li><p>Cycle Counter&#xFF1A;</p>
<ul>
<li>A 64-bit wide clock cycle counter that reflects how many clock cycles the processor has executed. This counter will continuously increment as long as the processor is in the execution state.</li>
<li>The CSR mcycle stores the lower 32 bits of the counter, and the CSR mcycleh stores the upper 32 bits of the counter. Please see the Bumblebee Processor Core Instruction Set Architecture Manual for more details.</li>
</ul>
</li>
<li><p>Instruction Retirement Counter&#xFF1A;</p>
<ul>
<li>The RISC-V architecture defines a 64-bit wide instruction completion counter that reflects how many instructions the processor successfully executed. This counter will increment if the processor executes an instruction successfully.</li>
<li><p>The CSR minstret stores the lower 32 bits of the counter, and the CSR minstreth stores the upper 32 bits of the counter. Please see the Bumblebee Processor Core Instruction Set Architecture Manual for more details.</p>
<pre><code>  Counter and the Instruction Retirement Counter are typically used to measure performance.By default, the counter is 0 after a reset and then increments itself continuously. Because the counter count consumes some dynamic power consumption, the Bumblebee Core implements additional control fields which software can configure the corresponding bits to enable or disable these counters. These bits can be used to stop the corresponding counter to save power when you do not need to use them.
</code></pre></li>
</ul>
<p>&#x200B;             the Bumblebee Processor Core Instruction Set Architecture Manual for more details about the CSR mcountinhibit.</p>
</li>
</ul>
<h2 id="213-timer-unit-of-the-bumblebee-core">2.13. <strong>TIMER Unit of the Bumblebee Core</strong><div id="2-13"></div></h2>
<p>&#x200B;      The RISC-V  architecture defines a 64-bit Timer Counter which is clocked by the system&#x2019;s low-speed Real Time Clock frequency. The value of this timer is reflected in the register mtime. The RISC-V architecture also defines a 64-bit mtimecmp register that used as a comparison value for the timer. A timer interrupt is generated if the value of mtime is greater than or equal to the value of mtimecmp.</p>
<p>&#x200B;        Note: The RISC-V architecture does not define the mtime and mtimecmp registers as CSR registers, but rather as Memory Address Mapped system registers. The specific memory mapped address is not defined by the RISC-V architecture, so it is defined by the implementation. In the Bumblebee Core, mtime/mtimecmp are both implemented in the TIMER Unit. Please see the Bumblebee Processor Core Instruction Set Architecture Manual for more details about the TIMER Unit.</p>
<h3 id="2131-timer-behavior-in-debug-mode"><strong>2.13.1.</strong> <strong>TIMER Behavior in Debug Mode</strong><div id="2-13-1"></div></h3>
<p>&#x200B;               When the Bumblebee Core is in debug mode, it occasionally executes some programs designated by the debugger, which is stored in the DEBUG unit and inivisible to the user, to support the debugger&#x2019;s function. If the timer keeps counting while executing these programs designated by the debugger, it does not truly reflect the true behavior of the program being debugged. Therefore, when the Bumblebee Core executes these programs, the timer will automatically stop counting.</p>
<h3 id="2132-timer-behavior-in-normal-mode"><strong>2.13.2.</strong> <strong>TIMER Behavior in Normal Mode</strong><div id="2-13-2"></div></h3>
<p>&#x200B;             By default, the timer has a value of 0 after a reset and then continue to increment itself. Because the counter count consumes some dynamic power consumption, the Bumblebee Core implements additional control fields which software can configure the corresponding bits to enable or disable these counters. These bits can be used to stop the corresponding counter to save power when you do not need to use them. Please see the Bumblebee Processor Core Instruction Set Architecture Manual for more details about the CSR mcountinhibit.</p>
<h2 id="214-low-power-mechanism-of-the-bumblebee-core">2.14 <strong>Low-Power Mechanism of the Bumblebee Core</strong><div id="2-14"></div></h2>
<p>&#x200B;                The low-power mechanism of the Bumblebee Core is reflected in the following aspects&#xFF1A;</p>
<ul>
<li>The clock of the main units in the Bumblebee Core are automatically gated off when they are in idle to reduce static power consumption. </li>
<li>The Bumblebee Core supports sleep mode through common WFI (Wait for Interrupt) and WFE (Wait for Event) mechanisms to achieve lower dynamic and static power consumption. Please see the Bumblebee Processor Core Instruction Set Architecture Manual for more details about &#x201C;Wait for Interrupt&#x201D; and &#x201C;Wait for Event&#x201D;.</li>
</ul>
<h3 id="2141-clock-control-entering-sleep-mode"><strong>2.14.1.</strong> <strong>Clock Control Entering Sleep Mode</strong><div id="2-14-1"></div></h3>
<p>&#x200B;               The Bumblebee Core can go to sleep by executing the WFI instruction. Please see the Bumblebee Processor Core Instruction Set Architecture Manual for more details about how to enter the sleep mode.</p>
<p>&#x200B;            The output  signal core_sleep_value of the Bumblebee Core can be used to indicate current sleep mode (0 or 1). Sleep mode 0 indicate the core is in shallow sleep mode, while sleep mode 1 means in deep sleep mode. Note: When entering to the deep sleep mode, the processor core will no longer be able to be debugged by JTAG interface.</p>
<p>&#x200B;            The key points of the clock control (reference scheme) of the core in sleep mode are shown as the followings:</p>
<ul>
<li>As shown in Figure 2-1, when the WFI is successfully executed, the output signal core_wfi_mode of the Bumblebee Core is asserted, indicating that the processor core has entered to the sleep mode after executing the WFI instruction; from the sight of SoC, the signal core_wfi_mode can be used to control the external gate logic to disable the core_clk.</li>
<li>If the Bumblebee Core entered the deep sleep mode (core_sleep_value is 1), then SoC can decide whether to disable the always on clock core_clk_aon according to its actual scenario.</li>
</ul>
<h3 id="2142-clock-control-of-exiting-the-sleep-mode"><strong>2.14.2.</strong> <strong>Clock Control of Exiting the Sleep Mode</strong><div id="2-14-2"></div></h3>
<p>&#x200B;                The core can be waked up by interrupt, event, or NMI. Please see the Bumblebee Processor Core Instruction Set Architecture Manual for more details about how to exit the sleep mode.</p>
<p>&#x200B;               The key points of the clock control when the core exits the sleep mode are shown as the followings:</p>
<ul>
<li>For the case that the core is waiting for an interrupt to wake up, because the Bumblebee Core can only handle the interrupt processed and distributed by ECLIC unit, then only the interrupt, which is enabled and has greater interrupt level than the interrupt threshold level, can wake up the core. Furthermore, whether enable the core_clk_aon inside the core needs to be handled carefully:<ul>
<li>As mentioned in Section 2.1, the TIMER unit is clocked by core_clk_aon.<ul>
<li>Assuming the SoC system has disabled the always-on clock core_clk_aon, the TIMER unit cannot generate timer or software interrupt because it has no clock.</li>
</ul>
</li>
<li>As mentioned in Section 2.1, the ECLIC unit is clocked by core_clk_aon.<ul>
<li>Assuming the SoC system has disabled the always-on clock core_clk_aon, then the external interrupt signal must kept asserted until the SoC system enable the signal core_clk_aon again. Otherwise, the ECLIC unit cannot sample the external interrupt signal because there is no clock, and the core cannot be woken up.</li>
</ul>
</li>
</ul>
</li>
<li>For the case that the core is waiting for an event or NMI to wake up, if the core samples (by the core_clk_aon) the input signal rx_evt (keep as &#x201C;1&#x201D; to indicate there is one event) or the input signal nmi (a rising edge to indicate there is one NMI), the core will be woken up. Furthermore, whether enable the core_clk_aon inside the core needs to be handled carefully:<ul>
<li>Assuming the SoC system has disabled the always-on clock core_clk_aon, then the input signal rx_evt or nmi must keep as 1 once be set until the SoC system turns on the clock core_clk_aon. Otherwise, the core cannot sample the Even or NMI as the sample logic has no clock, and the core will not wake up.</li>
</ul>
</li>
<li>The output signal core_wfi_mode will be 0 immediately after the core being waked up. Assuming the SoC system control the gate of core_clk using the signal core_wfi_mode, the working clock of core, core_clk will be enabled as soon as the signal core_wfi_mode is cleared to 0. </li>
</ul>
<h1 id="3-introduction-of-interfaces-of-the-bumblebee-core">3. <strong>Introduction of Interfaces of the Bumblebee Core</strong><div id="3"></div></h1>
<h2 id="31-introduction-of--interfaces-of-the-bumblebee-core"><strong>3.1.</strong> <strong>Introduction of  Interfaces of the Bumblebee core</strong><div id="3-1"></div></h2>
<p>&#x200B;                The Bumblebee Core has the following groups of interfaces:</p>
<ul>
<li><p>Clock and reset interface</p>
</li>
<li><p>Debugging interface</p>
</li>
<li><p>External interrupt interface</p>
</li>
<li><p>Bus interfaces&#xFF0C;including the following interfaces:</p>
<ul>
<li>Bus interfaces&#xFF0C;including the following interfaces:</li>
<li>DLM Master Interface&#xFF1A;the interface used to access the external DLM.</li>
<li>Private Peripheral Interface&#xFF1A;the interface used to access the Private Peripheral.</li>
<li>System Memory Interface&#xFF1A;the interface used to access the System Memory.</li>
</ul>
</li>
<li><p>Other function interface</p>
<pre><code>   most interface signals of the Bumblebee Core are the internal details of the MCU, we do not discuss about them too much herein.This document only describes an input signal mtime_toggle_a, because this signal is critical for MCU embedded software development.
</code></pre><p>   <strong><center>Table 3-1 mtime_toggle_a Interface Signals</center></strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Signal</th>
<th>Direction</th>
<th>Width</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>mtime_toggle_a</td>
<td>Input</td>
<td>1</td>
<td>mtime_toggke_a is a pulse signal from the SoC system, and used to drive the timer of the internal TIMER unit of the Core. <br> NOte&#xFF1A;<br>      This signal is treated as an asynchronous input signal.<br>This signal is synchronized within the Core (using several FF synchronizer).<br>       After the synchronization, both the rising edge and falling edge of the signal are sampled by the main clock of the core, and any detected edge will trigger the TIMER incrementation.<br>     It is recommended that use the output of the register driven by the slow clock (rtc_clk, whose frequency is halved frequency of core_clk_aon ) as the input of this signal. Then the self-increment frequency is equal to the frequency of the slow clock, as shown in the figure 3-1. Hence, the lower the frequency of the slow clock, the lower the self-increment frequency of the internal timer, the lower the dynamic power consumption.</td>
</tr>
</tbody>
</table>
<p><img src="1.assets/&#x56FE;&#x7247;3-1.png" alt="img"><img src="1.assets/&#x56FE;&#x7247;3-2-1566808443043.png" alt="img"> </p>
<p>&#x200B;    <strong><center>Figure3-1 Generation Diagram of the signal mtime_toggle_a</center></strong></p>
<p>&#x200B;    Note: in the MCU GD32VF103, rtc_clk runs at the frequency which is a quarter of the frequency of core_clk_aon, which means the internal TIMER counter is triggered by the signal mtimt_toggle_a, running at a self-increment frequency which is a quarter of the frequency of core_clk_aon.</p>
<footer class="page-footer"><span class="copyright">Copyright &#xA9; nuclei.com 2019 all right reserved&#xFF0C;powered by Gitbook</span><span class="footer-modification">&#x8BE5;&#x6587;&#x4EF6;&#x4E0A;&#x4F20;&#x65F6;&#x95F4;&#xFF1A;
2019-09-06 10:03:25
</span></footer>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                
                <a href="./#1-1" class="navigation navigation-next navigation-unique" aria-label="Next page: 1.1 Bumblebee Core Feature List">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"1.Introduction of the Bumblebee Processor Core","level":"1.1","depth":1,"next":{"title":"1.1 Bumblebee Core Feature List","level":"1.1.1","depth":2,"anchor":"#1-1","path":"README.md","ref":"README.md#1-1","articles":[]},"dir":"ltr"},"config":{"plugins":["disqus","advanced-emoji","expandable-chapters-small","splitter","back-to-top-button","chapter-fold","sharing-plus","tbfed-pagefooter"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright &copy nuclei.com 2019","modify_label":"è¯¥æä»¶ä¸ä¼ æ¶é´ï¼","modify_format":"YYYY-MM-DD HH:mm:ss"},"chapter-fold":{},"disqus":{"useIdentifier":false,"shortName":"gitbookuse"},"splitter":{},"search":{},"sharing-plus":{"qq":false,"all":["facebook","google","twitter","instapaper","linkedin","pocket","stumbleupon"],"douban":false,"facebook":true,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":true,"google":false,"viber":false,"stumbleupon":false,"qzone":false,"linkedin":false},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"back-to-top-button":{},"expandable-chapters-small":{},"advanced-emoji":{"embedEmojis":false},"sharing":{"facebook":false,"twitter":false,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":[]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"gitbook tutorial","links":{"gitbook":false,"sharing":{"google":false,"facebook":false,"twitter":false,"all":false}},"gitbook":"*","description":"nuclei book"},"file":{"path":"README.md","mtime":"2019-09-06T02:03:25.580Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-09-06T03:18:21.730Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/URI.js/1.16.1/URI.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-disqus/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-chapter-fold/chapter-fold.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing-plus/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

