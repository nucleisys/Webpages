
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>1.    Introduction of the Instruction Set and CSRs of the Bumblebee Core · gitbook tutorial</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-disqus/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-advanced-emoji/emoji-website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-chapter-fold/chapter-fold.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-tbfed-pagefooter/footer.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="./" />
    
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./#1">
            
                    
                    1.    Introduction of the Instruction Set and CSRs of the Bumblebee Core
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="./">
            
                <a href="./#1-1">
            
                    
                    1.1.    Introduction of the RISC-V Instruction Set Architecture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="READMEmd">
            
                <span>
            
                    
                    1.2.    Instruction Subset Supported by the Bumblebee Core
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="./">
            
                <a href="./#1-3">
            
                    
                    1.3.    Control and Status Registers
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="./">
            
                <a href="./#2">
            
                    
                    2.    The Privilege Modes of The Bumblebee Core
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="./">
            
                <a href="./#2-1">
            
                    
                    2.1.    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="./">
            
                <a href="./#2-2">
            
                    
                    2.2.    Privilege Modes
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.2.1" data-path="./">
            
                <a href="./#2-2-1">
            
                    
                    2.2.1.       Machine Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.2" data-path="./">
            
                <a href="./#2-2-2">
            
                    
                    2.2.2.    User Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.3" data-path="./">
            
                <a href="./#2-2-3">
            
                    
                    2.2.3.    Machine Sub-Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.4" data-path="./">
            
                <a href="./#2-2-4">
            
                    
                    2.2.4.    Read the Exceution Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.5" data-path="./">
            
                <a href="./#2-2-5">
            
                    
                    2.2.5.    Switching from Machine Mode to User Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.6" data-path="./">
            
                <a href="./#2-2-6">
            
                    
                    2.2.6.    Switching from User Mode to Machine Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.7" data-path="./">
            
                <a href="./#2-2-7">
            
                    
                    2.2.7.    Interrupts, Exceptions and NMIs Preemption
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="./">
            
                <a href="./#2-3">
            
                    
                    2.3.    Physical Memory Protection（PMP）
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="./">
            
                <a href="./#3">
            
                    
                    3.    Exception Operation of the Bumblebee Core
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="./">
            
                <a href="./#3-1">
            
                    
                    3.1.    Introduction of Exception
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="./">
            
                <a href="./#3-2">
            
                    
                    3.2.    Exception Masking
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="./">
            
                <a href="./#3-3">
            
                    
                    3.3.    Priority of Exception
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="README">
            
                <span>
            
                    
                    3.4.    Entering Exception Handling Mode
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.4.1" data-path="./">
            
                <a href="./#3-4-1">
            
                    
                    3.4.1.    Execute form the PC Defined by mtvec
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.2" data-path="./">
            
                <a href="./#3-4-2">
            
                    
                    3.4.2.    Update the CSR mcause
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.3" data-path="./">
            
                <a href="./#3-4-3">
            
                    
                    3.4.3.    Update the CSR mepc
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.4" data-path="./">
            
                <a href="./#3-4-4">
            
                    
                    3.4.4.    Update the CSR mtval
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.5" data-path="./">
            
                <a href="./#3-4-5">
            
                    
                    3.4.5.    Update the CSR mstatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.6" data-path="./">
            
                <a href="./#3-4-6">
            
                    
                    3.4.6.    Update the Privilege Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4.7" data-path="./">
            
                <a href="./#3-4-7">
            
                    
                    3.4.7.    Update the Machine Sub-Mode
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.5" data-path="./">
            
                <a href="./#3-5">
            
                    
                    3.5.    Exit the Exception Handling Mode
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.5.1" data-path="./">
            
                <a href="./#3-5-1">
            
                    
                    3.5.1.    Executing form the Address Defined by mepc
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5.2" data-path="./">
            
                <a href="./#3-5-2">
            
                    
                    3.5.2.    Update the CSR mstatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5.3" data-path="./">
            
                <a href="./#3-5-3">
            
                    
                    3.5.3.    Update the Privilege Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.5.4" data-path="./">
            
                <a href="./#3-5-4">
            
                    
                    3.5.4.    Update the Machine Sub-Mode
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.6" data-path="./">
            
                <a href="./#3-6">
            
                    
                    3.6.    Exception Service Routine
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.7" data-path="./">
            
                <a href="./#3-7">
            
                    
                    3.7.    Exception PreemptionException Preemption
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="./">
            
                <a href="./#4">
            
                    
                    4.    NMI Operation of the Bumblebee Core
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="./">
            
                <a href="./#4-1">
            
                    
                    4.1.    Introduction of NMI
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="./">
            
                <a href="./#4-2">
            
                    
                    4.2.    NMI Masking
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="./">
            
                <a href="./#4-3">
            
                    
                    4.3.    Entering NMI Handling Mode
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.3.1" data-path="./">
            
                <a href="./#4-3-1">
            
                    
                    4.3.1.    Execute from the PC Defined by mnvec
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.2" data-path="./">
            
                <a href="./#4-3-2">
            
                    
                    4.3.2.    Update the CSR mepc
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.3" data-path="./">
            
                <a href="./#4-3-3">
            
                    
                    4.3.3.    Update the CSR mcause
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.4" data-path="./">
            
                <a href="./#4-3-4">
            
                    
                    4.3.4.    Update the CSR mstatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.5" data-path="./">
            
                <a href="./#4-3-5">
            
                    
                    4.3.5.    Update the Privilege Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3.6" data-path="./">
            
                <a href="./#4-3-6">
            
                    
                    4.3.6.    Update the Machine Sub-Mode
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="./">
            
                <a href="./#4-4">
            
                    
                    4.4.    Exit the NMI Handling Mode
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.4.1" data-path="./">
            
                <a href="./#4-4-1">
            
                    
                    4.4.1.    Executing from the Address Defined by mepc
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.2" data-path="./">
            
                <a href="./#4-4-2">
            
                    
                    4.4.2.    Update the CSR mstatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.3" data-path="./">
            
                <a href="./#4-4-3">
            
                    
                    4.4.3.    Update the Privilege Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4.4" data-path="./">
            
                <a href="./#4-4-4">
            
                    
                    4.4.4.    Update the Machine Sub-Mode
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="./">
            
                <a href="./#4-5">
            
                    
                    4.5.    NMI Service Routine
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="./">
            
                <a href="./#4-6">
            
                    
                    4.6.    NMI/Exception Preemption
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.6.1" data-path="./">
            
                <a href="./#4-6-1">
            
                    
                    4.6.1.    Enter NMI/Exception Preemption
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6.2" data-path="./">
            
                <a href="./#4-6-2">
            
                    
                    4.6.2.    Exit NMI/Exception Preemption
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="./">
            
                <a href="./#5">
            
                    
                    5.    Interrupt Operation of the Bumblebee Core
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="./">
            
                <a href="./#5-1">
            
                    
                    5.1.    Introduction of Interrupt
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="./">
            
                <a href="./#5-2">
            
                    
                    5.2.    Enhanced Core Local Interrupt Controller （ECLIC）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="./">
            
                <a href="./#5-3">
            
                    
                    5.3.    Interrupt Type
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.3.1" data-path="./">
            
                <a href="./#5-3-1">
            
                    
                    5.3.1.    External Interrupt
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3.2" data-path="./">
            
                <a href="./#5-3-2">
            
                    
                    5.3.2.    Internal Interrupt
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.3.2.1" data-path="./">
            
                <a href="./#5-3-2-1">
            
                    
                    5.3.2.1    Software Interrupt
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3.2.2" data-path="./">
            
                <a href="./#5-3-2-2">
            
                    
                    5.3.2.2    Timer Interrupt
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3.2.3" data-path="./">
            
                <a href="./#5-3-2-3">
            
                    
                    5.3.2.3    Memory Access Error Interrupt
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="./">
            
                <a href="./#5-4">
            
                    
                    5.4.    Interrupt Masking
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.4.1" data-path="./">
            
                <a href="./#5-4-1">
            
                    
                    5.4.1.    Global Interrupt Masking
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4.2" data-path="./">
            
                <a href="./#5-4-2">
            
                    
                    5.4.2.    Specified Interrupt Masking
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="./">
            
                <a href="./#5-5">
            
                    
                    5.5.    Interrupt Levels, Priorities and Arbitration
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6" data-path="./">
            
                <a href="./#5-6">
            
                    
                    5.6.    Entering Interrupt Handling Mode
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.6.1" data-path="./">
            
                <a href="./#5-6-1">
            
                    
                    5.6.1.    Execute from a new PC 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6.2" data-path="./">
            
                <a href="./#5-6-2">
            
                    
                    5.6.2.    Update the Privilege Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6.3" data-path="./">
            
                <a href="./#5-6-3">
            
                    
                    5.6.3.    Update the Machine Sub-Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6.4" data-path="./">
            
                <a href="./#5-6-4">
            
                    
                    5.6.4.    Update the CSR mepc
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.6.5" data-path="./">
            
                <a href="./#5-6-5">
            
                    
                    5.6.5.    Update the CSRs mcause and mstatus
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5.7" data-path="./">
            
                <a href="./#5-7">
            
                    
                    5.7.    Exit the Interrupt Handling Mode
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.7.1" data-path="./">
            
                <a href="./#5-7-1">
            
                    
                    5.7.1.    Executing from the Address Defined by mepc
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.7.2" data-path="./">
            
                <a href="./#5-7-2">
            
                    
                    5.7.2.    Update the CSRs mcause and mstatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.7.3" data-path="./">
            
                <a href="./#5-7-3">
            
                    
                    5.7.3.    Update the Privilege Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.7.4" data-path="./">
            
                <a href="./#5-7-4">
            
                    
                    5.7.4.    Update the Machine Sub-Mode
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5.8" data-path="./">
            
                <a href="./#5-8">
            
                    
                    5.8.    Interrupt Vector Table
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.9" data-path="./">
            
                <a href="./#5-9">
            
                    
                    5.9.    Context Saving and Restoring
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.10" data-path="./">
            
                <a href="./#5-10">
            
                    
                    5.10.    Interrupt Response Latency
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.11" data-path="./">
            
                <a href="./#5-11">
            
                    
                    5.11.    Interrupt Preemption
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.12" data-path="./">
            
                <a href="./#5-12">
            
                    
                    5.12.    Interrupt Tail-Chaining
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.13" data-path="./">
            
                <a href="./#5-13">
            
                    
                    5.13.    Vectored and Non-Vectored Processing Mode of Interrupts
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.13.1" data-path="./">
            
                <a href="./#5-13-1">
            
                    
                    5.13.1. Feature and Latency of Non-Vectored Processing Mode
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.13.1.1" data-path="./">
            
                <a href="./#5-13-1-1">
            
                    
                    5.13.1.1 Preemption of Non-Vectored Interrupt
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.13.1.2" data-path="./">
            
                <a href="./#5-13-1-2">
            
                    
                    5.13.1.2 Non-Vectored Interrupt Tail-Chaining
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.13.1.3" data-path="./">
            
                <a href="./#5-13-1-3">
            
                    
                    5.13.1.3 Vectored Processing Mode
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5.13.2" data-path="./">
            
                <a href="./#5-13-2">
            
                    
                    5.13.2.    Vectored Processing Mode
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.13.2.1" data-path="./">
            
                <a href="./#5-13-2-1">
            
                    
                    5.13.2.1 Feature and Latency of Vectored Processing Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.13.2.2" data-path="./">
            
                <a href="./#5-13-2-2">
            
                    
                    5.13.2.2 Preemption of Vectored Interrupt
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.13.2.3" data-path="./">
            
                <a href="./#5-13-2-3">
            
                    
                    5.13.2.3 Vectored Interrupt Tail-Chaining
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="./">
            
                <a href="./#6">
            
                    
                    6.    The TIMER and the ECLIC Unit of the Bumblebee Core
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="./">
            
                <a href="./#6-1">
            
                    
                    6.1.    Introduction of the TIMER Unit
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1.1" data-path="./">
            
                <a href="./#6-1-1">
            
                    
                    6.1.1.    TIMER Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.1.2" data-path="./">
            
                <a href="./#6-1-2">
            
                    
                    6.1.2.    TIMER Registers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.1.3" data-path="./">
            
                <a href="./#6-1-3">
            
                    
                    6.1.3.    Time Counter Register mtime
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.1.4" data-path="./">
            
                <a href="./#6-1-4">
            
                    
                    6.1.4.    Pause the Timer Counter through mstop
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.1.5" data-path="./">
            
                <a href="./#6-1-5">
            
                    
                    6.1.5.    Generate the Timer Interrupt through mtime and mtimecmp
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.1.6" data-path="./">
            
                <a href="./#6-1-6">
            
                    
                    6.1.6.    Generating the Software Interrupt through msip
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="./">
            
                <a href="./#6-2">
            
                    
                    6.2.    The ECLIC Unit
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.2.1" data-path="./">
            
                <a href="./#6-2-1">
            
                    
                    6.2.1.    Introduction of the ECLIC unit
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.2" data-path="./">
            
                <a href="./#6-2-2">
            
                    
                    6.2.2.    ECLIC interrupt target
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.3" data-path="./">
            
                <a href="./#6-2-3">
            
                    
                    6.2.3.    ECLIC Interrupt Source
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.4" data-path="./">
            
                <a href="./#6-2-4">
            
                    
                    6.2.4.    ECLIC Interrupt Source ID
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.5" data-path="./">
            
                <a href="./#6-2-5">
            
                    
                    6.2.5.    ECLIC Registers
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.2.5.1" data-path="./">
            
                <a href="./#6-2-5-1">
            
                    
                    6.2.5.1    cliccfg
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.5.2" data-path="./">
            
                <a href="./#6-2-5-2">
            
                    
                    6.2.5.2    clicinfo
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.5.3" data-path="./">
            
                <a href="./#6-2-5-3">
            
                    
                    6.2.5.3    mth
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.5.4" data-path="./">
            
                <a href="./#6-2-5-4">
            
                    
                    6.2.5.4    clicintip[i]
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.5.5" data-path="./">
            
                <a href="./#6-2-5-5">
            
                    
                    6.2.5.5    clicintie[i]
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.5.6" data-path="./">
            
                <a href="./#6-2-5-6">
            
                    
                    6.2.5.6    clicintattr[i]
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.5.7" data-path="./">
            
                <a href="./#6-2-5-7">
            
                    
                    6.2.5.7    clicintctl[i]
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6.2.6" data-path="./">
            
                <a href="./#6-2-6">
            
                    
                    6.2.6.    ECLIC Interrupt Enable Bit (IE)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.7" data-path="./">
            
                <a href="./#6-2-7">
            
                    
                    6.2.7.    ECLIC Interrupt Pending Bit（IP）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.8" data-path="./">
            
                <a href="./#6-2-8">
            
                    
                    6.2.8.    ECLIC Interrupt Source Level or Edge-Triggered Attribute
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.9" data-path="./">
            
                <a href="./#6-2-9">
            
                    
                    6.2.9.   ECLIC Interrupt Level and Priority
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.10" data-path="./">
            
                <a href="./#6-2-10">
            
                    
                    6.2.10. ECLICI Interrupt Vectored and Non-Vectored Processing Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.11" data-path="./">
            
                <a href="./#6-2-11">
            
                    
                    6.2.11.ECLIC Interrupt Threshold Level
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.12" data-path="./">
            
                <a href="./#6-2-12">
            
                    
                    6.2.12. ECLIC Interrupt Arbitration Mechanism
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.13" data-path="./">
            
                <a href="./#6-2-13">
            
                    
                    6.2.13.ECLIC Interrupt Taken, Preemption and Tail-Chaining
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="./">
            
                <a href="./#7">
            
                    
                    7.    Bumblebee Core CSRs Descriptions
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="./">
            
                <a href="./#7-1">
            
                    
                    7.1.    Bumblebee Core CSRs Overview
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="./">
            
                <a href="./#7-2">
            
                    
                    7.2.    Bumblebee Core CSRs List
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="./">
            
                <a href="./#7-3">
            
                    
                    7.3.    Accessibility of CSR in the Bumblebee Core 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="./">
            
                <a href="./#7-4">
            
                    
                    7.4.    Bumblebee Core RISC-V Standard CSR
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.4.1" data-path="./">
            
                <a href="./#7-4-1">
            
                    
                    7.4.1.    misa
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.2" data-path="./">
            
                <a href="./#7-4-2">
            
                    
                    7.4.2.    mie
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.3" data-path="./">
            
                <a href="./#7-4-3">
            
                    
                    7.4.3.    mvendorid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.4" data-path="./">
            
                <a href="./#7-4-4">
            
                    
                    7.4.4.    marchid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.5" data-path="./">
            
                <a href="./#7-4-5">
            
                    
                    7.4.5.    mimpid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.6" data-path="./">
            
                <a href="./#7-4-6">
            
                    
                    7.4.6.    mhartid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.7" data-path="./">
            
                <a href="./#7-4-7">
            
                    
                    7.4.7.    mstatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.8" data-path="./">
            
                <a href="./#7-4-8">
            
                    
                    7.4.8.    The mie field in mstatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.9" data-path="./">
            
                <a href="./#7-4-9">
            
                    
                    7.4.9.    The MPIE and MPP fields in mstatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.10" data-path="./">
            
                <a href="./#7-4-10">
            
                    
                    7.4.10.    The FS field in mstatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.11" data-path="./">
            
                <a href="./#7-4-11">
            
                    
                    7.4.11.    The XS field in mstatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.12" data-path="./">
            
                <a href="./#7-4-12">
            
                    
                    7.4.12.    The SD field in mstatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.13" data-path="./">
            
                <a href="./#7-4-13">
            
                    
                    7.4.13.    mtvec
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.14" data-path="./">
            
                <a href="./#7-4-14">
            
                    
                    7.4.14.    mtvt
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.15" data-path="./">
            
                <a href="./#7-4-15">
            
                    
                    7.4.15.    mscratch
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.16" data-path="./">
            
                <a href="./#7-4-16">
            
                    
                    7.4.16.    mepc
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.17" data-path="./">
            
                <a href="./#7-4-17">
            
                    
                    7.4.17.    mcause
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.18" data-path="./">
            
                <a href="./#7-4-18">
            
                    
                    7.4.18.    mtval（mbadaddr）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.19" data-path="./">
            
                <a href="./#7-4-19">
            
                    
                    7.4.19.    mip
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.20" data-path="./">
            
                <a href="./#7-4-20">
            
                    
                    7.4.20.    mnxti
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.21" data-path="./">
            
                <a href="./#7-4-21">
            
                    
                    7.4.21.    mintstatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.22" data-path="./">
            
                <a href="./#7-4-22">
            
                    
                    7.4.22.    mscratchcsw
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.23" data-path="./">
            
                <a href="./#7-4-23">
            
                    
                    7.4.23.    mscratchcswl
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.24" data-path="./">
            
                <a href="./#7-4-24">
            
                    
                    7.4.24.    mcycle and mcycleh
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.25" data-path="./">
            
                <a href="./#7-4-25">
            
                    
                    7.4.25.    minstret and minstreth
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.26" data-path="./">
            
                <a href="./#7-4-26">
            
                    
                    7.4.26.    cycle and cycleh
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.27" data-path="./">
            
                <a href="./#7-4-27">
            
                    
                    7.4.27.    instret and instreth
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.28" data-path="./">
            
                <a href="./#7-4-28">
            
                    
                    7.4.28.    time and timeh
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4.29" data-path="./">
            
                <a href="./#7-4-29">
            
                    
                    7.4.29.    mcounteren
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="./">
            
                <a href="./#7-5">
            
                    
                    7.5.    Bumblebee Core Customized CSR
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.5.1" data-path="./">
            
                <a href="./#7-5-1">
            
                    
                    7.5.1.    mcountinhibit
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.2" data-path="./">
            
                <a href="./#7-5-2">
            
                    
                    7.5.2.    mnvec
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.3" data-path="./">
            
                <a href="./#7-5-3">
            
                    
                    7.5.3.    msubm
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.4" data-path="./">
            
                <a href="./#7-5-4">
            
                    
                    7.5.4.    mmisc_ctl
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.5" data-path="./">
            
                <a href="./#7-5-5">
            
                    
                    7.5.5.    msavestatus
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.6" data-path="./">
            
                <a href="./#7-5-6">
            
                    
                    7.5.6.    msaveepc1和msaveepc2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.7" data-path="./">
            
                <a href="./#7-5-7">
            
                    
                    7.5.7.    msavecause1和msavecause2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.8" data-path="./">
            
                <a href="./#7-5-8">
            
                    
                    7.5.8.    pushmsubm
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.9" data-path="./">
            
                <a href="./#7-5-9">
            
                    
                    7.5.9.    mtvt2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.10" data-path="./">
            
                <a href="./#7-5-10">
            
                    
                    7.5.10.    jalmnxti
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.11" data-path="./">
            
                <a href="./#7-5-11">
            
                    
                    7.5.11.    pushmcause
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.12" data-path="./">
            
                <a href="./#7-5-12">
            
                    
                    7.5.12.    pushmepc
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.13" data-path="./">
            
                <a href="./#7-5-13">
            
                    
                    7.5.13.    sleepvalue
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.14" data-path="./">
            
                <a href="./#7-5-14">
            
                    
                    7.5.14.    txevt
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5.15" data-path="./">
            
                <a href="./#7-5-15">
            
                    
                    7.5.15.    wfe
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="./">
            
                <a href="./#8">
            
                    
                    8.    Bumblebee Low-Power Mechanism
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="./">
            
                <a href="./#8-1">
            
                    
                    8.1.    Enter the Sleep Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="./">
            
                <a href="./#8-2">
            
                    
                    8.2.    Exit the Sleep Mode
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.2.1" data-path="./">
            
                <a href="./#8-2-1">
            
                    
                    8.2.1.    Wake Up by NMI
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2.2" data-path="./">
            
                <a href="./#8-2-2">
            
                    
                    8.2.2.    Wake Up by Interrupt
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2.3" data-path="./">
            
                <a href="./#8-2-3">
            
                    
                    8.2.3.    Wake Up by Event
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2.4" data-path="./">
            
                <a href="./#8-2-4">
            
                    
                    8.2.4.    Wake Up by Debug Request
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="./">
            
                <a href="./#8-3">
            
                    
                    8.3.    Wait for Interrupt Mechanism
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="./">
            
                <a href="./#8-4">
            
                    
                    8.4.    Wait for Event Mechanism
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >1.    Introduction of the Instruction Set and CSRs of the Bumblebee Core</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <p>For more comprehensive information, please visit www.riscv-mcu.com<a href="http://www.riscv-mcu.com" target="_blank">www.riscv-mcu.com</a></p>
<p>This PDF document is maintained in<a href="https://github.com/nucleisys/Bumblebee_Core_Doc" target="_blank">https://github.com/nucleisys/Bumblebee_Core_Doc</a></p>
<h1 id="bumblebee-core-architecture-manual">Bumblebee Core Architecture Manual</h1>
<h1 id="1-introduction-of-the-instruction-set-and-csrs-of-the-bumblebee-core"><strong>1.</strong> <strong>Introduction of the Instruction Set and CSRs of the Bumblebee CORE</strong><div id="1"></div></h1>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Processor Core, or Bumblebee core for short&#xFF0C;is a commercial RISC-V processor core customized by Nuclei System Technology and Gigadevice for general-purpose MCU products for IoT or other ultra-low-power applications. It is dedicated to MCU products of model GD32VF103.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;For an introduction to the hardware features of the Bumblebee Core, please refer to the Datasheet for Bumblebee Processor Core. This documentation provides a detailed introduction to the Bumblebee Processor Core supported instruction set architecture.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Note: The Bumblebee core used for this MCU is jointly developed by Nuclei System Technology and Andes Technology. Nuclei System Technology provides authorization services and technical support.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;At present, Nuclei System Technology can authorize fully domestically controllable N200 series ultra-low power commercial processor core IPs, as well as other multiple series (300/600/900 series) 32-bit or 64-bit high-performance embedded processor core IPs, and provide customers with processor IP customization services.</p>
<h2 id="11-introduction-of-the-risc-v-instruction-set-architecture"><strong>1.1. Introduction of the RISC-V Instruction Set Architecture</strong><div id="1-1"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core is designed based on the RISC-V Instruction Set Manual Volume I: User-Level ISA Version 2.2 (riscv-spec-v2.2.pdf). Users can register and access the full text(<a href="https://riscv.org/specifications/" target="_blank">https://riscv.org/specifications/</a>) for free on the RISC-V Foundation website.</p>
<h2 id="12instruction-subset-supported-by-the-bumblebee-core"><strong>1.2.Instruction Subset Supported by the Bumblebee Core</strong><div id="1-2"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;RISC-V has been designed to support extensive customization and specialization. The base integer ISA can be extended with one or more optional instruction-set extensions. The instruction sets supported by the Bumblebee Core are the followings:</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;RV32 Architecture: 32-bit address space, and 32-bit general purpose registers.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;-I: Supports 32 general purpose registers. </p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;-M: Supports the RISC-V standard multiplication and division instructions.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;-C: Supports the RISC-V standard compressed instructions, which reduces code size by adding short 16-bit instruction encodings for common operations.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;-A: Supports the RISC-V standard atomic instructions.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;According to the RISC-V standard naming convention, the combination of these above instruction extensions can be represented as RV32IMAC&#x3002;</p>
<h2 id="13-control-and-status-registers"><strong>1.3. Control and Status Registers</strong><div id="1-3"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Some control and status registers (CSRs) are defined in the RISC-V architecture to configure or record some execution status of the core. CSRs are registers internal to the core, which are accessed using a dedicated 12-bit address space.</p>
<h1 id="2-the-privilege-modes-of-the-bumblebee-core"><strong>2. The Privilege Modes of The Bumblebee Core</strong><div id="2"></div></h1>
<h2 id="21-introduction"><strong>2.1. Introduction</strong><div id="2-1"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core is designed based on The RISC-V Instruction Set Manual Volume II: Privileged Architecture Version 1.10 (riscv-privileged-v1.10.pdf). Users can register and access the full text (<a href="https://riscv.org/specifications/" target="_blank">https://riscv.org/specifications/</a>) for free on the RISC-V Foundation website.</p>
<h2 id="22-privilege-modes"><strong>2.2. Privilege Modes</strong><div id="2-2"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core supports two privilege modes:</p>
<p>&#x200B;      &#xA0;&#xA0; &#xA0;&#xA0; Machine Mode is the mandatory privilege mode, which is encoded as 0x3.</p>
<p>&#x200B;      &#xA0;&#xA0;&#xA0;&#xA0; User Mode is configurable, which is encoded as 0x0.</p>
<h3 id="221-machine-mode"><strong>2.2.1. Machine Mode</strong><div id="2-2-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Machine Mode of the Bumblebee Core has the following features:</p>
<p>&#x200B;      &#xA0;&#xA0;&#xA0;&#xA0;  - The privilege mode of the core is Machine Mode after a reset by default.</p>
<p>&#x200B;      &#xA0;&#xA0;&#xA0;&#xA0;  - Machine Mode has the accessibility to all CSRs&#x3002;</p>
<h3 id="222-user-mode"><strong>2.2.2. User Mode</strong><div id="2-2-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;User Mode of the Bumblebee Core has the following features&#xFF1A;</p>
<p>&#x200B;      &#xA0;&#xA0;&#xA0;&#xA0;  - User Mode only has the accessibility to a part of the CSRs. Please see Section 7.3 for more details</p>
<h3 id="223-machine-sub-mode"><strong>2.2.3. Machine Sub-Mode</strong><div id="2-2-3"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Machine Mode of the Bumblebee Core has 4 sub-mode, named Machine Sub-Mode:&#xFF1A;</p>
<p>&#x200B;      &#xA0;&#xA0;&#xA0;&#xA0; - Normal Mode&#xFF08;Machine Sub-Mode as 0x0&#xFF09;&#xFF1A;</p>
<p>&#x200B;      &#xA0;&#xA0;  - The core is in this sub-mode after a reset. The core will work in this sub-mode until it encounters an exception, NMI or interrupt&#x3002;</p>
<p>&#x200B;      &#xA0;&#xA0; -Exception Handling Mode&#xFF08;Machine Sub-Mode as 0x2&#xFF09;&#xFF1A;
&#x200B;      &#xA0;&#xA0;  - The core is in this sub-mode when it is handling an exception.
&#x200B;      &#xA0;&#xA0;  - Please see Chapter 3 for details about the exception operation.</p>
<p>&#x200B;      &#xA0;&#xA0; NMI Handling Mode&#xFF08;Encoded as 0x3&#xFF09;&#xFF1A;
&#x200B;      &#xA0;&#xA0;  - The core is in this sub-mode when it is handling an NMI.
&#x200B;      &#xA0;&#xA0;  - Please see Chapter 4 for details about the NMI operation.</p>
<p>&#x200B;      &#xA0;&#xA0;- Interrupt Handling Mode&#xFF08;Encoded  as 0x1&#xFF09;&#xFF1A;
&#x200B;      &#xA0;&#xA0;  - The core is in this sub-mode when it is handling an interrupt.
&#x200B;      &#xA0;&#xA0;  - Please see Chapter 5 for details about the interrupt operation.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The TYP field of the CSR msubm indicates the current Machine Sub-Mode of the core. Therefore, the software can read this CSR to lookup the current Machine Sub-Mode. For more details about the CSR msubm, please refer to the Section 7.5.3.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Note: In the RISC-V architecture, the taking of an exception, NMI or interrupt are collectively Trap.</p>
<h3 id="224-read-the-execution-mode"><strong>2.2.4. Read the Execution Mode</strong><div id="2-2-4"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The key points of reading the execution mode are the following:&#xFF1A;</p>
<p>&#x200B;      &#xA0;&#xA0;- According to the architecture definition of the RISC-V, there is no register can reflect what is current privilege mode of the core, so the software cannot access the information about current privilege mode
&#x200B;      &#xA0;&#xA0;- The Bumblebee Core has 4 Machine Sub-Modes which are indicated in the TYP filed of the CSR msubm, so the software can access this CSR to read current Machine Sub-Mode</p>
<h3 id="225-switching-from-machine-mode-to-user-mode"><strong>2.2.5. Switching from Machine Mode to User Mode</strong><div id="2-2-5"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mret instruction can be executed directly in Machine Mode. Switching from Machine Mode to User Mode can only be done by executing the mret instruction. As described in Section 2.2.3, the Machine Mode may be in four different status as the followings:&#xFF1A;</p>
<p>&#x200B;      &#xA0;&#xA0;- If the core is in normal machine mode, the hardware behavior of executing the mret instruction is the same as executing the mret instruction in exception handling mode, please see Section 3.5 for details
&#x200B;      - Therefore, if you want to switch from Machine Mode to User Mode in normal machine mode, you need to modify the value of the MPP field in the CSR mstatus first, and then execute the mret instruction to complete the switching. A typical program code looks like the followings&#xFF1A;</p>
<pre><code>    /* Switch Machine sub-mode to User mode */

&#x200B;    li t0&#xFF0C; MSTATUS_MPP  // the value of MSTATUS_MPP is 0x00001800&#xFF0C;proper mstatus MPP field bit

&#x200B;                        // for more about mstatus register Section 7.4.7

&#x200B;    csrc mstatus,  t0   // set mstatus registe MPP bit to 0

&#x200B;      la t0&#xFF0C; 1f       // set the PC address of the former tag 1 value to t0          

&#x200B;      csrw mepc,  t0   // set t0 value to mepc CSR register

&#x200B;      mret             // mret&#xFF0C;turn the mode toUser Mode&#xFF0C;and begin in the address tag 1

    1:                  // the address of tag 1
</code></pre><ul>
<li>If the core is in exception handling mode, please see Section 3.5 for the details about the hardware operation of mret execution.</li>
<li>Commonly, mret is used to exit from exception handling mode and restore the previous execution mode.</li>
<li>If the software intends to exit from Machine Mode to User Mode (or normal machine mode), the software needs to modify the value of MPP field of the CSR mstatus, and then execute an mret instruction.<ul>
<li>If the core is in interrupt handling mode, please see Section 5.7 for the details about the hardware operation of mret execution.</li>
</ul>
</li>
<li>Commonly, mret is used to exit from interrupt handling mode and restore the previous execution mode.</li>
<li>If the software intends to exit from Machine Mode to User Mode (or normal machine mode), the software needs to modify the value of MPP field of the CSR mstatus, and then execute an mret instruction.<ul>
<li>If the core is in NMI handling mode, please see Section 4.4 for the details about the hardware operation of mret execution.</li>
</ul>
</li>
<li>Commonly, mret is used to exit from NMI handling mode and restore the previous execution mode.</li>
<li>If the software intends to exit from Machine Mode to User Mode (or normal machine mode), the software needs to modify the value of MPP field of the CSR mstatus, and then execute an mret instruction.</li>
</ul>
<p>Note&#xFF1A;</p>
<ul>
<li>Execution of mret in User Mode will raise an illegal instruction exception.</li>
</ul>
<h3 id="226-switching-from-user-mode-to-machine-mode"><strong>2.2.6. Switching from User Mode to Machine Mode</strong><div id="2-2-6"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core can only switch from User Mode to Machine Mode by taking an exception, interrupt or NMI:&#xFF1A;</p>
<ul>
<li>Taking an exception and enter exception handling mode, please see Section 3.4 for more details.<ul>
<li>Note: The software can execute an ecall instruction to enter the exception handler of ecall.</li>
</ul>
</li>
<li>Taking an interrupt and enter interrupt handling mode, please see Section 5.6 for more details.</li>
<li>Taking an NMI and enter NMI handling mode, please see Section 4.3 for more details</li>
</ul>
<h3 id="227-interrupts-exceptions-and-nmis-preemption"><strong>2.2.7. Interrupts, Exceptions and NMIs Preemption</strong><div id="2-2-7"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;An interrupt can preempt another interrupt, and an exception can preempt another exception, but NMI cannot preempt another NMI:</p>
<ul>
<li>If the core is in NMI handling mode, and it encounters another NMI, then the new NMI will be masked. Therefore, NMI cannot preempt another NMI. Please see Section 4.6 for more details.&#x3002;</li>
<li>If the core is in exception handling mode, and it encounters another exception, then an exception preemption will happen. Please see Section 3.5 for more details.</li>
<li>If the core is in interrupt handling mode, and it encounters another interrupt, then an interrupt preemption will happen. Please see Section 5.11 for more details.</li>
<li>Preemption also happens among interrupts, exceptions and NMIs as the followings:</li>
<li>If the core is in interrupt handling mode, and it encounters an exception, then the core will enter exception handling mode.</li>
<li>If the core is in NMI handling mode, and it encounters an exception, then the core will enter exception handling mode.</li>
<li>If the core is in interrupt handling mode, and it encounters an NMI, then the core will enter NMI handling mode.</li>
<li>If the core is in exception handling mode, and it encounters an NMI, then the core will enter NMI handling mode.</li>
<li>Note: The global interrupt-enable bit MIE is clear by hardwire when the core is in exception/NMI handling mode, so the core will not take any interrupt.</li>
</ul>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core implements a &#x201C;Two Levels of NMI/Exception State Save Stacks&#x201D; to ensure that the core can restore the context of the previous state before taking a preemption between exceptions and NMIs. Please see Section 4.6 for more details.</p>
<h2 id="23-physical-memory-protection&#xFF08;pmp&#xFF09;"><strong>2.3. Physical Memory Protection&#xFF08;PMP&#xFF09;</strong><div id="2-3"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Since the Bumblebee Core is a low-power core designed for microcontrollers, it does not support the Memory Management Unit, so all the address access operations are using physical addresses. In order to perform memory access protection and isolation according to memory physical address of different devices and execution privilege mode, the RISC-V standard architecture defines a physical memory protection mechanism: Physical Memory Protection (PMP) unit.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Note: the Bumblebee Core does not support PMP unit.</p>
<h1 id="3-exception-operation-of-the-bumblebee-core"><strong>3. Exception Operation of the Bumblebee Core</strong><div id="3"></div></h1>
<h2 id="31-introduction-of-exception"><strong>3.1. Introduction of Exception</strong><div id="3-1"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Exception mechanism, is that the processor core suddenly encounters an abnormal event when executing the program instruction stream, and aborts execution of the current program, and turns to handle the exception instead. The key points are as follows:</p>
<ul>
<li>The &#x201C;abnormal event&#x201D; which the core encounters is called an exception. An exception is caused by an internal event in the core or an event during the execution of the program, such as a hardwire failure, a program failure, or the execution of a special system service instruction. In short, it is a core-internal issue.</li>
<li>When the exception is taken, the core will enter the exception handler program.</li>
</ul>
<h2 id="32-exception-masking"><strong>3.2. Exception Masking</strong><div id="3-2"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;In the RISC-V architecture, exception is not maskable, which means if the core encounters an exception, it must stop current execution and turns to handle the exception.</p>
<h2 id="33-priority-of-exception"><strong>3.3. Priority of Exception</strong><div id="3-3"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;It is possible that the core encounters multiple exceptions at the same time, so exceptions also have priority. The priority of the exception is shown in Table 3-1. The smaller the exception code, the higher the priority of the exception</p>
<h2 id="34-entering-exception-handling-mode"><strong>3.4. Entering Exception Handling Mode</strong><div id="3-4"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Taking an exception, hardware behaviors of the Bumblebee Core are described as below. Note that the following operations are done simultaneously in one cycle:</p>
<p>Stop the execution of the current program, and start from the PC address defined by the CSR mtvec.</p>
<p>Update the following CSR registers:</p>
<ul>
<li>mcause&#xFF08;Machine Cause Register&#xFF09;</li>
<li>mepc&#xFF08;Machine Exception Program Counter&#xFF09;</li>
<li>mtval&#xFF08;Machine Trap Value Register &#xFF09;</li>
<li>mstatus&#xFF08;Machine Status Register&#xFF09;</li>
<li>Update Privilege Mode and Machine Sub-Mode&#x3002;</li>
</ul>
<p>The overall process of exception is shown in Figure 3-1.</p>
<p><img src="chapter3/3.4/3.4.assets/1-1566288783599.png" alt=""></p>
<p>&#x200B;                                                                       <strong><center>Figure 3-1The overall process of exception</center></strong></p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;These will be detailed in the following parts</p>
<h3 id="341-execute-form-the-pc-defined-by-mtvec"><strong>3.4.1. Execute form the PC Defined by mtvec</strong><div id="3-4-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core jumps to the PC defined by the CSR mtvec after encountering an exception.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The CSR mtvec is a both readable and writeable CSR register, so the software can modify its value. The detailed format of this CSR is shown in Table 7-3.</p>
<h3 id="342-update-the-csr-mcause"><strong>3.4.2. Update the CSR mcause</strong><div id="3-4-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When the Bumblebee Core takes one exception, the CSR mcause is updated (hardware automatically) simultaneously to indicate the type of encountered exception. The software can read this register to query the specific cause of the exception.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The format of mcause is shown in Table 7-6, where the lower 5 bits are the encoding filed of the exception, which is used to indicate the type of exceptions, as shown in Table 3-1.</p>
<p>&#x200B;                                       <strong><center>Table 3-1  Exception Code in mcause</center></strong></p>
<table>
<thead>
<tr>
<th>Exception Code</th>
<th>Error and</th>
<th>Async/Sync</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Instruction address misaligned</td>
<td>Sync</td>
<td>The instruction PC address is not aligned. Note: This exception type is not possible in processors configured with a subset of &quot;C&quot; extension instructions.</td>
</tr>
<tr>
<td>1</td>
<td>Instruction access fault</td>
<td>Sync</td>
<td>Instruction access fault.</td>
</tr>
<tr>
<td>2</td>
<td>Illegal instruction</td>
<td>Sync</td>
<td>Illegal instruction</td>
</tr>
<tr>
<td>3</td>
<td>Breakpiont</td>
<td>Sync</td>
<td>The RISC-V architecture defines the EBREAK instruction, which occurs when the processor executes the instruction and enters the exception service routine. This instruction is often used by the debugger (Debugger), such as setting breakpoints.</td>
</tr>
<tr>
<td></td>
<td>Load address misaligned</td>
<td>Sync</td>
<td>Load instruction fetch address is not aligned. Note: The Bumblebee kernel does not support data memory read and write operations with unaligned addresses, so this exception is raised when the access address is not aligned.</td>
</tr>
<tr>
<td>5</td>
<td>Load access fault</td>
<td>Not precise Async</td>
<td>Load  access fault</td>
</tr>
<tr>
<td>6</td>
<td>Store/AMO address misaligned</td>
<td>Sync</td>
<td>Store or AMO instruction fetch address is not aligned. Note: The Bumblebee kernel does not support data memory read and write operations with unaligned addresses, so this exception is raised when the access address is not aligned.</td>
</tr>
<tr>
<td>7</td>
<td>Store/AMO access fault</td>
<td>Not precise Async</td>
<td>Store or AMO instruction access fault.</td>
</tr>
<tr>
<td>8</td>
<td>Environment call from U-mode</td>
<td>Sync</td>
<td>User Mode execute the ecall instruction. The RISC-V architecture defines an ecall instruction that will enter the exception service routine when the processor executes the instruction. This instruction is often used by software to force entry into the exception mode.</td>
</tr>
<tr>
<td>11</td>
<td>Environment call from M-mode</td>
<td>Sync</td>
<td>Machine Mode execute the ecall instruction. The RISC-V architecture defines an ecall instruction that will enter the exception service routine when the processor executes the instruction. This instruction is often used by software to force entry into the exception mode.</td>
</tr>
</tbody>
</table>
<h3 id="343-update-the-csr-mepc"><strong>3.4.3. Update the CSR mepc</strong><div id="3-4-3"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The return address when the Bumblebee Core exit the exception handler is stored in the CSR mepc. When the core takes an exception, the hardware will update the CSR mepc automatically, and the value in this CSR will be the return address when exit the exception handler. After handling the exception, the PC value is restored from this CSR to return to the execution point that was previously stopped.</p>
<p>Note:</p>
<ul>
<li>When an exception is taken into M-mode, mepc is written with the PC address of the instruction that encountered the exception.</li>
<li>Although the CSR mepc can be updated automatically encountering an exception, it is a both readable and writeable register, so the software can modify it explicitly.</li>
</ul>
<h3 id="344-update-the-csr-mtval"><strong>3.4.4. Update the CSR mtval</strong><div id="3-4-4"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When the Bumblebee Core takes an exception, the hardware will update the CSR mtval (Machine Trap Value Register) automatically to indicate the memory access address or instruction encoding that caused the current exception:</p>
<ul>
<li>When a hardware breakpoint is triggered, or an instruction-fetch, load, or store address-misaligned, access, or page-fault exception occurs, mtval is written with the faulting effective address.</li>
<li>On an illegal instruction trap, mtval is written with the first 32 bits of the encoding of the faulting instruction.</li>
</ul>
<h3 id="345-update-the-csr-mstatus"><strong>3.4.5. Update the CSR mstatus</strong><div id="3-4-5"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The format of the CSR mstatus is shown in Table 7-2. When the Bumblebee Core takes one exception, the hardware will update some fields of the CSR mstatus (Machine Status Register) automatically:</p>
<ul>
<li>The value of mstatus.MPIE will be updated as the previous value of mstatus.MIE before taking the exception, as described in Section 8.2. The value of mstatus.MPIE is used to restore the previous value of mstatus.MIE after handling the exception.</li>
<li>The value of mstatus.MIE will be updated to 0 (which means the global interrupt is disabled and all the interrupts are masked)</li>
<li>The value of mstatus.MPP will be updated to the Privilege Mode before taking the exception, as described in Section 8.2. The value of mstatus.MPP is used to restore the previous Privilege Mode after handling the exception.</li>
</ul>
<h3 id="346update-the-privilege-mode"><strong>3.4.6.Update the Privilege Mode</strong><div id="3-4-6"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Exceptions are handled in Machine Mode. Once an exception is taken, the privilege mode of the core will be updated to Machine Mode.</p>
<h3 id="347-update-machine-sub-mode"><strong>3.4.7. Update Machine Sub-Mode</strong><div id="3-4-7"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Machine Sub-Mode of the Bumblebee Core is indicated in the msubm.TYP filed in real time. When the core takes an exception, the Machine Sub-Mode will be updated to exception handling mode, so:</p>
<ul>
<li>The value of msubm.PTYP will be updated to the value of msub.TYP before taking the exception, as shown in Figure 3.2. The value of msubm.PTYP will be used to restore the value of msubm.PTYP after exiting the exception handler.</li>
<li>The filed msubm.TYP is updated to exception handling mode, as shown in Figure 3.2, to reflect the current Machine Sub-Mode is &#x201C;exception handling mode&#x201D;.</li>
</ul>
<p><img src="chapter3/3.4/3.4.7.assets/2.png" alt=""></p>
<p>&#x200B;                                            <strong><center>Figure 3-2 The CSR updating when enter/exit the exception</center></strong></p>
<h2 id="35-exit-the-exception-handling-mode"><strong>3.5. Exit the Exception Handling Mode</strong><div id="3-5"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;After handling the exception, the core needs to exit from the exception handler eventually.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Since the exception is handling in Machine Mode, the software has to execute mret to exit the exception handler. The hardware behavior of the processor after executing mret instruction is as follows. Note that the following hardware behaviors are done simultaneously in one cycle:</p>
<ul>
<li>Stop the execution of the current program, and start from the PC address defined by the CSR mepc.</li>
<li>Update the CSR mstatus (Machine Status Register), as described in Figure 3-2, and update the Privilege Mode and the Machine Sub-Mode.</li>
</ul>
<p>The overall process of exiting an exception is shown in Figure 3-3</p>
<p><img src="chapter3/3.5/3.5.assets/3.png" alt=""></p>
<p>&#x200B;                                                               <strong><center>Figure  3-3 The overall process of exiting an exception</center></strong></p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;These will be detailed in the following parts.</p>
<h3 id="351-executing-form-the-address-defined-by-mepc"><strong>3.5.1. Executing form the Address Defined by mepc</strong><div id="3-5-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Taking an exception, the CSR mepc is updated at the same time to store the PC value of the instruction that encountered the exception. Through this mechanism, it means that the core returns to the PC address of the instruction that encountered the exception when executes the mret instruction. So that the aborted program is continued to execute.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Note: It may be necessary to update the value of mepc by software before exiting an exception. For example, if the exception is raised by an ecall or ebreak instruction, then the value of mepc is updated to the pc of the ecall or ebreak instruction. If the exception exit without modify the value of mepc, then it will jump back to the ecall or ebreak instruction again, causing an infinite loop (executing the ecall or ebreak instruction and raising a same exception). The correct way is to change the value of mepc to the next instruction to the ecall or ebreak by software in the exception handler. Since ecall/ebreak is a 4-byte instruction, it is reasonable to rewrite the mepc=mepc+4.</p>
<h3 id="352-update-the-csr-mstatus"><strong>3.5.2. Update the CSR mstatus</strong><div id="3-5-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The format of the CSR mstatus is shown in Table 7-2. After executing one mret instruction, the hardware will update some fields of the CSR mstatus:</p>
<ul>
<li>The value of mstatus.MIE is restored by the value of mstatus.MPIE.</li>
<li>The value of mstatus.MPIE is updated to 1.</li>
<li>The updated value of mstatus.MPP is divided into the following two cases:<ul>
<li>When User Mode is configured, mstatus.MPP is updated to 0x0.</li>
<li>When User Mode is not configured, mstatus.MPP is updated to 0x11.</li>
</ul>
</li>
</ul>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Taking an exception, the value of mstatus.MPIE will be updated to the value of mstatus.MIE before taking the exception, as described in Figure 3-2. The value of mstatus.MIE will be restored by the value of mstatus.MPIE after the execution of mret. Through this mechanism, it means that after the execution of mret, the value of mstatus.MIE is restored to the previous value before taking the exception (assuming the previous value of mstatus.MIE is 1, it means that the global interrupt-enable bit is set).</p>
<h3 id="353update-the-privilege-mode"><strong>3.5.3.Update the Privilege Mode</strong><div id="3-5-3"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Taking an exception, the value of mstatus.MPP was updated to the Privilege Mode of the core before taking the exception, and after executing the mret instruction, the value of Privilege Mode is restored by the value of mstatus.MPP, as described in Figure 3-2. Through this mechanism, the core is guaranteed to return to the Privilege Mode before taking the exception.</p>
<h3 id="354-update-the-machine-sub-mode"><strong>3.5.4. Update the Machine Sub-Mode</strong><div id="3-5-4"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The value of msubm.TYP indicates the Machine Sub-Mode of the Bumblebee Core in real time. After executing the mret instruction, the hardware will automatically restore the core&#x2019;s Machine Sub-Mode by the value of msubm.PTYP:</p>
<ul>
<li>Taking an exception, the value of msubm.PTYP is updated to the Machine Sub-Mode before taking the exception. After executing the mret instruction, the hardware will automatically restore the Machine Sub-Mode using the value of msubm.PTYP, as shown in Figure 3-2. Through this mechanism, the Machine Sub-Mode of the core is restored to the same mode before taking the exception.</li>
</ul>
<h2 id="36-exception-service-routine"><strong>3.6. Exception Service Routine</strong><div id="3-6"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When the core takes one exception, it starts to execute the program starting at the address defined by mtvec, and this program is usually an exception service routine. The program can decide to jump further to the specified exception service routine by querying the exception code in the CSR mcause. For example, if the exception code in mcause is 0x2, which indicates that this exception is caused by an illegal instruction, then it can jump to the specific handler for illegal instruction fault.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Note: Since there is no hardware to save and restore the execution context automatically when take or exit an exception, so the software needs to explicitly use the instruction (in assembly language) for context saving and restoring. Please refer to a complete exception service routine of the specified MCU chip.</p>
<h2 id="37-exception-preemption"><strong>3.7. Exception Preemption</strong><div id="3-7"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core supports two levels of NMI/Exception State Save Stacks. Please See Section 4.6 for more details.</p>
<h1 id="4-nmi-operation-of-the-bumblebee-core"><strong>4. NMI Operation of the Bumblebee Core</strong><div id="4"></div></h1>
<h2 id="41-introduction-of-nmi"><strong>4.1. Introduction of NMI</strong><div id="4-1"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;NMI (Non-Maskable Interrupt) is a special input signal of the processor, often used to indicate system-level emergency errors (such as external hardware failures, etc.) After encountering the NMI, the processor should abort execution of the current program immediately and process the NMI error instead.</p>
<h2 id="42-nmi-masking"><strong>4.2. NMI Masking</strong><div id="4-2"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;In the RISC-V architecture, NMI is not maskable, which means if the core encounters an NMI, it must stop current execution and turns to handle the NMI.</p>
<h2 id="43-entering-nmi-handling-mode"><strong>4.3. Entering NMI Handling Mode</strong><div id="4-3"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Taking an NMI, hardware behaviors of the Bumblebee Core are described as below. Note that the following operations are done simultaneously in one cycle:</p>
<ul>
<li>Stop the execution of the current program, and start from the PC address defined by the CSR mnvec.</li>
<li>Update the following CSR registers:<ul>
<li>mepc&#xFF08;Machine Exception Program Counter &#xFF09;</li>
<li>mstatus&#xFF08;Machine Status Register&#xFF09;</li>
<li>mcause&#xFF08;Machine Cause Register&#xFF09;</li>
</ul>
</li>
<li>Update the Privilege Mode and Machine Sub-Mode of the core.</li>
<li>The overall process of NMI is shown in Figure 4-1.</li>
</ul>
<p><img src="chapter4/4.3/4.3.assets/4.png" alt=""></p>
<p>&#x200B;                                                          <strong><center>Figure 4-1 The overall process of NMI</center></strong></p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;These will be detailed in the following parts.</p>
<h3 id="431-execute-from-the-pc-defined-by-mnvec"><strong>4.3.1. Execute from the PC Defined by mnvec</strong><div id="4-3-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core jumps to the PC defined by the CSR mnvec after encountering an NMI. The CSR mnvec has two potential values:&#xFF1A;</p>
<ul>
<li>When mmisc_ctl[9]=1, the value of mnvec is equal to the value of mtvec, which means NMIs and exceptions share the same trap entry address.</li>
<li>When mmisc_ctl[9]=0, the value of mnvec equals to the value of reset_vector which is the pc value after a reset.</li>
</ul>
<h3 id="432-update-the-csr-mepc"><strong>4.3.2. Update the CSR mepc</strong><div id="4-3-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The return address when the Bumblebee Core exit the NMI handler is stored in the CSR mepc. When the core takes an NMI, the hardware will update the CSR mepc automatically, and the value in this CSR will be the return address when exit the NMI handler. After handling the NMI, the PC value is restored from this CSR to return to the execution point that was previously stopped.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Note&#xFF1A;</p>
<ul>
<li>When an NMI is taken, the CSR mepc is updated to the PC of the next instruction of the one encountered the NMI (Because the instruction encounters the NMI has been executed correctly). Then after exiting the NMI, the program will continue to execute from the next instruction of the instruction that encounters the NMI.</li>
<li>Although the CSR mepc can be updated automatically encountering an NMI, it is a both readable and writeable register, so the software can modify it explicitly.</li>
</ul>
<h3 id="433-update-the-csr-mcause"><strong>4.3.3. Update the CSR mcause</strong><div id="4-3-3"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The format of the CSR mcause is shown in Table 7-6. The Bumblebee Core will save the ID of the trap into the CSR mcause by the hardware automatically when take a trap. The value of mcause indicates the reason of trap. Interrupts, exceptions and NMIs all have their own specified Trap ID. The Trap ID of NMI has two potential values:</p>
<ul>
<li>When mmisc_ctl[9]=1&#xFF0C;the Trap ID of NMI is 0xfff.</li>
<li>When mmisc_ctl[9]=0&#xFF0C;the Trap ID of NMI is 0x1.</li>
</ul>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The software can recognize the Trap reason querying the Trap ID, and build the corresponding trap handler program for different types of traps.</p>
<h3 id="434-update-the-csr-mstatus"><strong>4.3.4. Update the CSR mstatus</strong><div id="4-3-4"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The format of the CSR mstatus is shown in Table 7-2. When the Bumblebee Core takes one NMI, the hardware will update some fields of the CSR mstatus (Machine Status Register) automatically:</p>
<ul>
<li>The value of mstatus.MPIE will be updated as the previous value of mstatus.MIE before taking the NMI, as described in Section 8.2. The value of mstatus.MPIE is used to restore the previous value of mstatus.MIE after handling the NMI.</li>
<li>The value of mstatus.MIE will be updated to 0 (which means the global interrupt is disabled and all the interrupts are masked)</li>
<li>The value of mstatus.MPP will be updated to the Privilege Mode before taking the NMI, as described in Section 8.2. The value of mstatus.MPP is used to restore the previous Privilege Mode after handling the NMI.</li>
</ul>
<h3 id="435-update-the-privilege-mode"><strong>4.3.5. Update the Privilege Mode</strong><div id="4-3-5"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;NMI is handed in Machine Mode, so the privilege mode will be switched to Machine Mode when the core takes an NMI.</p>
<h3 id="436-update-the-machine-sub-mode"><strong>4.3.6. Update the Machine Sub-Mode</strong><div id="4-3-6"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Machine Sub-Mode of the Bumblebee Core is indicated in the msubm.TYP filed in real time. When the core takes an NMI, the Machine Sub-Mode will be updated to NMI handling mode, so:</p>
<ul>
<li>The value of msubm.PTYP will be updated to the value of msub.TYP before taking the NMI, as shown in Figure 4-2. The value of msubm.PTYP will be used to restore the value of msubm.PTYP after exiting the NMI handler.</li>
<li>The filed msubm.TYP is updated to NMI handling mode, as described in Figure 4-2, to reflect the current Machine Sub-Mode is &#x201C;NMI handling mode&#x201D;.</li>
</ul>
<p><img src="chapter4/4.3/4.3.6.assets/5.png" alt=""></p>
<p>&#x200B;                                                  <strong><center>Figure 4-2 The CSR updating when enter/exit the NMI</center></strong></p>
<h2 id="44-exit-the-nmi-handling-mode"><strong>4.4. Exit the NMI Handling Mode</strong><div id="4-4"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;After handling the NMI, the core needs to exit from the NMI handler eventually, and return to execute the main program.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Since the NMI is handling in Machine Mode, the software has to execute mret to exit the NMI handler. The hardware behavior of the processor after executing mret instruction is as follows. Note that the following hardware behaviors are done simultaneously in one cycle:</p>
<ul>
<li>Stop the execution of the current program, and start from the PC address defined by the CSR mepc.</li>
<li>Update the CSR mstatus (Machine Status Register).</li>
<li>Update the Privilege Mode and the Machine Sub-Mode.</li>
</ul>
<p>The overall process of exiting an NMI is shown in Figure 4-3.</p>
<p><img src="chapter4/4.4/4.4.assets/6.png" alt=""></p>
<p>&#x200B;                                                            <strong><center>Figure 4-3 The overall process of exiting an NMI</center></strong></p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;These will be detailed in the following parts.</p>
<h3 id="441-executing-from-the-address-defined-by-mepc"><strong>4.4.1. Executing from the Address Defined by mepc</strong><div id="4-4-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When an NMI is taking, the mepc is updated to the PC value of the next instruction. Through this mechanism, executing the mret instruction, the core will return to the next instruction of the instruction encountered the NMI, and continue to execute the program.</p>
<h3 id="442-update-the-csr-mstatus"><strong>4.4.2. Update the CSR mstatus</strong><div id="4-4-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The format of the CSR mstatus is shown in Table 7-2. After executing one mret instruction, the hardware will update some fields of the CSR mstatus:</p>
<ul>
<li>The value of mstatus.MIE is restored by the value of mstatus.MPIE.</li>
<li>The value of mstatus.MPIE is updated to 1.</li>
<li>The updated value of mstatus.MPP is divided into the following two cases:<ul>
<li>When User Mode is configured, mstatus.MPP is updated to 0x0.</li>
<li>When User Mode is not configured, mstatus.MPP is updated to 0x11.</li>
</ul>
</li>
</ul>
<p>Taking an NMI, the value of mstatus.MPIE will be updated to the value of mstatus.MIE before taking the NMI, as shown in Figure 8.2. The value of mstatus.MIE will be restored by the value of mstatus.MPIE after the execution of mret. Through this mechanism, it means that after the execution of mret, the value of mstatus.MIE is restored to the previous value before taking the NMI (assuming the previous value of mstatus.MIE is 1, it means that the global interrupt-enable bit is set).</p>
<h3 id="443-update-the-privilege-mode"><strong>4.4.3. Update the Privilege Mode</strong><div id="4-4-3"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Taking an NMI, the value of mstatus.MPP was updated to the Privilege Mode of the core before taking the NMI, and after executing the mret instruction, the value of Privilege Mode is restored by the value of mstatus.MPP, as described in Figure 42. Through this mechanism, the core is guaranteed to return to the Privilege Mode before taking the NMI.</p>
<h3 id="444-update-the-machine-sub-mode"><strong>4.4.4. Update the Machine Sub-Mode</strong><div id="4-4-4"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The value of msubm.TYP indicates the Machine Sub-Mode of the Bumblebee Core in real time. After executing the mret instruction, the hardware will automatically restore the core&#x2019;s Machine Sub-Mode by the value of msubm.PTYP:</p>
<ul>
<li>Taking an NMI, the value of msubm.PTYP is updated to the Machine Sub-Mode before taking the NMI. After executing the mret instruction, the hardware will automatically restore the Machine Sub-Mode using the value of msubm.PTYP, as shown in Figure 42. Through this mechanism, the Machine Sub-Mode of the core is restored to the same mode before taking the NMI.</li>
</ul>
<h2 id="45-nmi-service-routine"><strong>4.5. NMI Service Routine</strong><div id="4-5"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When the core takes an NMI, it will jump to execute the program at the address defined by mnvec, which is usually the NMI service routine.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Note&#xFF1A;Since there is no hardware to save and restore the execution context automatically when take or exit an NMI, so the software needs to explicitly use the instruction (in assembly language) for context saving and restoring. Please refer to a complete NMI service routine of the specified MCU chip.</p>
<h2 id="46-nmiexception-preemption"><strong>4.6. NMI/Exception Preemption</strong><div id="4-6"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core has implemented self-defined Two Levels of NMI/Exception State Save Stacks which can save up to 3-level NMI/Exception core execution states. This implementation supports 2-level recoverable NMI/Exception preemption.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Note&#xFF1A; Since NMI is masked when the core is in NMI handling mode, one NMI cannot preempt another NMI. The Bumblebee Core can support 3 kinds of NMI/Exception preemption:</p>
<ul>
<li>An NMI preempts an exception</li>
<li>An exception preempts another exception</li>
<li>An exception preempts another NMI</li>
</ul>
<p><img src="chapter4/4.6/4.6.assets/7.png" alt=""></p>
<p>&#x200B;                             <strong><center>Figure 4-4 Two Levels of NMI/Exception State Save Stacks</center></strong></p>
<h3 id="461-enter-nmiexception-preemption"><strong>4.6.1. Enter NMI/Exception Preemption</strong><div id="4-6-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When take an NMI or exception, hardware behaviors of the Bumblebee Core are described in the Figure4-4&#x3002;</p>
<ul>
<li>Stop executing the current program, and jump to a new PC to execute.<ul>
<li>If it is an exception trap, then the jump target PC is the address defined in mtvec.</li>
<li>If it is an NMI trap, then the jump target PC is the address defined in mnvec.</li>
</ul>
</li>
<li>Updates the following relevant CSRs&#x2019; specified fields:<ul>
<li>mepc: record the PC encountered the handling NMI/Exception, and can be used to restore the PC after exiting the handling NMI/Exception.</li>
<li>msaveepc1: the first level NMI/Exception State Save Stack, records the PC encountered the first level preempted NMI/Exception which is preempted by the handling NMI/Exception. This CSR is used to restore the value of mepc when the core returns from the handling NMI/Exception.</li>
<li>msaveepc2: the second level NMI/Exception State Save Stack, records the PC encountered the second level preempted NMI/Exception which is preempted by the first level preempted NMI/Exception. This CSR is used to restore the value of msaveepc1 when the core returns from the handling NMI/Exception.</li>
<li>mstatus:<ul>
<li>MPIE: save the value of MIE before taking the handling NMI/Exception.</li>
<li>MPP: save the value of Privilege Mode before taking the handling NMI/Exception.</li>
</ul>
</li>
<li>msavestatus:<ul>
<li>MPIE1: the first level NMI/Exception State Save Stack, records the value of MIE when encountered the first level preempted NMI/Exception which is preempted by the handling NMI/Exception. This CSR is used to restore the value of MPIE when the core returns from the handling NMI/Exception.</li>
<li>MPIE2: the second level NMI/Exception State Save Stack, records the value of MIE when encountered the second level preempted NMI/Exception which is preempted by the first level preempted NMI/Exception. This CSR is used to restore the value of MPIE1 when the core returns from the handling NMI/Exception.</li>
<li>MPP1: the first level NMI/Exception State Save Stack, records the Privilege Mode when encountered the first level preempted NMI/Exception which is preempted by the handling NMI/Exception. This CSR is used to restore the value of MPP when the core returns from the handling NMI/Exception.</li>
<li>MPP2: the second level NMI/Exception State Save Stack, records the Privilege Mode when encountered the second level preempted NMI/Exception which is preempted by the first level preempted NMI/Exception. This CSR is used to restore the value of MPP1 when the core returns from the handling NMI/Exception.</li>
</ul>
</li>
<li>mcause: save the cause of the handling NMI/Exception.</li>
<li>msavecause1: the first level NMI/Exception State Save Stack, records the trap cause when encountered the first level preempted NMI/Exception which is preempted by the handling NMI/Exception.</li>
<li>msavecause2: the second level NMI/Exception State Save Stack, records the trap cause when encountered the second level preempted NMI/Exception which is preempted by the first level preempted NMI/Exception.</li>
<li>msubm:<ul>
<li>TYP&#xFF1A;save the trap type of the current handling NMI/Exception.</li>
<li>PTYP: save the trap type before taking the handling NMI/Exception.</li>
<li>PTYP1:the first level NMI/Exception State Save Stack, records the Machine Sub-Mode when encountered the first level preempted NMI/Exception which is preempted by the handling NMI/Exception. This CSR is used to restore the value of PTYP when the core returns from the handling NMI/Exception.</li>
<li>PTYP2&#xFF1A;the second level NMI/Exception State Save Stack, records the Machine Sub-Mode when encountered the second level preempted NMI/Exception which is preempted by the first level preempted NMI/Exception. This CSR is used to restore the value of PTYP1 when the core returns from the handling NMI/Exception.</li>
</ul>
</li>
</ul>
</li>
<li>NMI/Exception is handling in Machine Mode, so the Privilege Mode will be switched to the Machine Mode when the core take one NMI/Exception.</li>
</ul>
<h3 id="462exit-nmiexception-preemption"><strong>4.6.2.Exit NMI/Exception Preemption</strong><div id="4-6-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;After handling the NMI/Exception, the core needs to exit from the NMI/Exception handler eventually, and return to execute the main program or handle the next level preempted NMI/Exception. Before exit the current NMI/Exception handler, the relevant CSRs and core status need to be restored by executing the mret instruction. The hardware behavior of the processor after executing mret instruction are shown in Figure 44, which can be described in short as the follows:</p>
<ul>
<li>Stop the execution of the current program, and start from the PC address defined by the CSR mepc.</li>
<li>Update some fields of the relevant CSRs as the follows:&#xFF1A;<ul>
<li>mepc&#xFF08;Machine Exception Program Counter&#xFF09;:&#xF06C;update to the value saved in msaveepc1, which is the PC encountered the first level preempted NMI/Exception.</li>
<li>msaveepc1&#xFF1A;the first level NMI/Exception State Save Stack, update to the value of msaveepc2, which is the PC encountered the second level preempted NMI/Exception. mstatus&#xFF08;Machine Status Register&#xFF09;</li>
<li>mstatus&#xFF08;Machine Status Register&#xFF09;<ul>
<li>MPIE&#xFF1A;update to the value of MPIE1, which is the value of MIE when the core encountered the first level preempted NMI/Exception. </li>
<li>MPP:  update to the value of MPP1, which is the Privilege Mode when the core encountered the first level preempted NMI/Exception. </li>
</ul>
</li>
<li>msavestatus:<ul>
<li>MPIE1&#xFF1A;the first level NMI/Exception State Save Stack, update to the value of msavestatus.MPIE2 which is the value of MIE when the core encountered the second level preempted NMI/Exception.</li>
<li>MPP1&#xFF1A;the first level NMI/Exception State Save Stack, update to the value of msavestatus.MPP2 which is the Privilege Mode when the core encountered the second level preempted NMI/Exception.</li>
</ul>
</li>
<li>mcause&#xFF08;Machine Cause Register&#xFF09;&#xFF1A;  update to the value of msavecause1 which is the cause of the first preempted NMI/Exception. </li>
<li>msavecause1&#xFF1A;the first level NMI/Exception State Save Stack, update to the value of msavecause2 which is the cause of the second level preempted NMI/Exception. </li>
<li>msubm&#xFF08;Machine Sub-Mode Register&#xFF09;<ul>
<li>TYP&#xFF1A;update to the value of msubm.PTYP which is the trap type of the handling NMI/Exception.</li>
<li>PTYP: update to the value of msubm.PTYP1 which is the trap type of the first level preempted NMI/Exception.</li>
<li>PTYP1: the first level NMI/Exception State Save Stack, updates to the value of msubm.PTYP2 which is the trap type of the second level preempted NMI/Exception when one mret is executed. </li>
</ul>
</li>
</ul>
</li>
<li>According to the value of mstatus.MPP to update the Privilege Mode.</li>
</ul>
<h1 id="5-5interrupt-operation-of-the-bumblebee-core"><strong>5. 5.Interrupt Operation of the Bumblebee Core</strong><div id="5"></div></h1>
<h2 id="51-introduction-of-interrupt"><strong>5.1. Introduction of Interrupt</strong><div id="5-1"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Interrupt mechanism, that is, the core is suddenly interrupted by other requests during the execution of the current program, and the current program is stopped, and then the core turns to handle other requests. After handling other requests, the core goes back and continue to execute the previous program.
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The key points of interrupts are the followings:</p>
<ul>
<li>The &#x201C;other request&#x201D; interrupts the processor core is called Interrupt Request. The source of this request is called the Interrupt Source. The interrupt s0urce is usually comes from outside the core which is called the External Interrupt Source, but some of the interrupt sources are core-internal, which are called the Internal Interrupt Sources.</li>
<li>The program used to handle the &#x201C;other request&#x201D; is called the Interrupt Service Routine (ISR).</li>
<li>Interrupt mechanism is a normal mechanism, not an error situation. Once the core receives an interrupt request, it needs to save the context of the current execution status, which is referred as &#x201C;context saving&#x201D;. After processing the request, the core needs to restore the previous status, thereby continuing to execute the previously interrupted program, referred to &#x201C;context restoring&#x201D;.</li>
<li>There may be multiple interrupt sources that simultaneously initiate requests to the core, and an arbitration is needed to select one from these sources to determine which interrupt source is prioritized. This scenario is called &#x201C;interrupt arbitration&#x201D;, and different interrupts can be assigned levels and priorities to facilitate the arbitration, so there is a concept of &#x201C;interrupt level&#x201D; and &#x201C;interrupt priority&#x201D;.</li>
</ul>
<h2 id="52-enhanced-core-local-interrupt-controllereclic"><strong>5.2. Enhanced Core Local Interrupt ControllerECLIC</strong><div id="5-2"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As described in Section 7.4.13, the Bumblebee Core supports the &#x201C;default interrupt mode&#x201D; and &#x201C;ECLIC interrupt mode&#x201D; by different software configurations. Herein only the &#x201C;ECLIC interrupt mode&#x201D; is introduced.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core has implemented with the Enhanced Core Local Interrupt Controller which can be used to manage multiple interrupt sources. All types of interrupts in the Bumblebee Core (except for debug interrupts) are managed by ECLIC. See Section 6.2 for details of ECLIC. See Section 5.3 for an introduction to all interrupt types supported by the Bumblebee Core.&#x3002;</p>
<h2 id="53-interrupt-type"><strong>5.3. Interrupt Type</strong><div id="5-3"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The types of interrupts supported by the Bumblebee Core are shown in Figure 5-1.</p>
<p><img src="chapter5/5.3/5.3.assets/8.png" alt=""></p>
<p>&#x200B;                                                              <strong><center>Figure 5-1 Interupt Types</center></strong></p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;These will be detailed in the following parts&#x3002;</p>
<h3 id="531-external-interrupt"><strong>5.3.1. External Interrupt</strong><div id="5-3-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;An external interrupt is an interrupt initiated from outside the core. External interrupts allow user to connect to an external interrupt source, such as an interrupt generated by an external device like UART, GPIO and so on.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Note&#xFF1A;The Bumblebee Core supports multiple external interrupt sources, all of which are managed by the ECLIC.</p>
<h3 id="532-internal-interrupt"><strong>5.3.2. Internal Interrupt</strong><div id="5-3-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core has several core-internal private interrupts as the followings:</p>
<ul>
<li>Software Interrupt</li>
<li>Timer Interrupt</li>
</ul>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Note&#xFF1A;The internal interrupts of the Bumblebee Core are also managed by the ECLIC.</p>
<h4 id="5321-software-interrupt"><strong>5.3.2.1 Software Interrupt</strong><div id="5-3-2-1"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The key points of the software interrupt are the followings&#xFF1A;</p>
<ul>
<li>The Bumblebee Core implements a TIMER unit, and an msip register is defined in the TIMER unit, through which software interrupts can be generated. Please see Section 6.1.6 for details.</li>
<li>Note: Software interrupts are also managed by the ECLIC.</li>
</ul>
<h4 id="5322-timer-interrupt"><strong>5.3.2.2 Timer Interrupt</strong><div id="5-3-2-2"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The key points of the software interrupt are the following:</p>
<ul>
<li>The Bumblebee Core implements a TIMER unit, and a counter is defined in the TIMER unit, through which time interrupts can be generated. Please see Section 6.1.5 for details.
generated. Please see Section 6.1.6 for details.</li>
<li>Note: Timer interrupts are also managed by the ECLIC.</li>
</ul>
<h4 id="5323-memory-access-error-interrupt"><strong>5.3.2.3 Memory Access Error Interrupt</strong><div id="5-3-2-3"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; The key points of the interrupt conversed by &#x201C;Memory Access Error Exception&#x201D; are as follows:</p>
<ul>
<li>When the Bumblebee Core encounters a &#x201C;Memory Access Error Exception&#x201D;, it dose not generate an exception, but instead convert it to the corresponding internal interrupt, which is handled as an interrupt.</li>
</ul>
<h2 id="54-interrupt-masking"><strong>5.4. Interrupt Masking</strong><div id="5-4"></div></h2>
<h3 id="541-global-interrupt-masking"><strong>5.4.1. Global Interrupt Masking</strong><div id="5-4-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Interrupts can be masked by the control bit MIE in the CSR mstatus of the Bumblebee Core. Please see Section 7.4.8 for details</p>
<h3 id="542-specified-interrupt-masking"><strong>5.4.2. Specified Interrupt Masking</strong><div id="5-4-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;For different interrupt sources, ECLIC assigns its own interrupt enable register to each interrupt sources. Users can configure the corresponding ECLIC register to manage some specified interrupt sources. Please see Section 6.2.6 for details.</p>
<h2 id="55-interrupt-levels-priorities-and-arbitration"><strong>5.5. Interrupt Levels, Priorities and Arbitration</strong><div id="5-5"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When multiple interrupts are initiated at the same time, an arbitration is required. For the Bumble Core, the ECLIC manages all interrupts. ECLIC assigns its own interrupt level and priority registers to each interrupt source. Users can configure the ECLIC registers to manage the level and priority of the specified interrupt sources. When multiple interrupts occur simultaneously, the ECLIC will select the one has the highest priority to be taken, as shown in Figure 5-2. Please see Section 6.2.9 for more details.</p>
<p><img src="chapter5/5.5.assets/9.png" alt=""></p>
<p>&#x200B;                                                                 <strong><center>Figure 5-2 Arbitration among Multiple Interrupts</center></strong></p>
<h2 id="56-entering-interrupt-handling-mode"><strong>5.6. Entering Interrupt Handling Mode</strong><div id="5-6"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Taking an interrupt, hardware behaviors of the Bumblebee Core are described as below. Note that the following operations are done simultaneously in one cycle:</p>
<ul>
<li>Stop the execution of the current program, and jump to another PC to execute.<ul>
<li>mepc&#xFF08;Machine Exception Program Counter&#xFF09;</li>
<li>mstatus&#xFF08;Machine Status Register&#xFF09;</li>
<li>mcause&#xFF08;Machine Cause Register&#xFF09;</li>
<li>mintstatus &#xFF08;Machine Interrupt Status Register&#xFF09;</li>
</ul>
</li>
<li>Update the Privilege Mode and Machine Sub-Mode of the core.</li>
<li>The overall process of interrupt is shown in Figure5-3</li>
</ul>
<p><img src="chapter5/5.6/5.6.assets/10.png" alt=""></p>
<p>&#x200B;                                                                   <strong><center>Figure 5-3 The Ovreall Process of Interrupt</center></strong></p>
<p>These will be detailed in the following parts.</p>
<h3 id="561-execute-from-a-new-pc"><strong>5.6.1. Execute from a new PC</strong><div id="5-6-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Each interrupt source of the ECLIC can be set to vectored or non-vectored interrupt (via the shv filed of the register clicintattr[i]). The key points are as follows:</p>
<ul>
<li>If the interrupt is configured as a vectored interrupt, then the core will jump to the corresponding target address of this interrupt in the Vector Table Entry when this interrupt is taken. For details about the Interrupt Vector Table, please refer to Section 5.8. For details of the vectored processing mode, please refer to Section 5.13.2.</li>
<li>If the interrupt is configured as a non-vectored interrupt, then the core will jump to a common base address shared by all interrupts. For details of the non-vectored processing mode, please refer to Section 5.13.1.</li>
</ul>
<h3 id="562update-the-privilege-mode"><strong>5.6.2.Update the Privilege Mode</strong><div id="5-6-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The privilege mode will be switched to Machine Mode when the core takes an Interrupt.</p>
<h3 id="563-update-the-machine-sub-mode"><strong>5.6.3. Update the Machine Sub-Mode</strong><div id="5-6-3"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Machine Sub-Mode of the Bumblebee Core is indicated in the msubm.TYP filed in real time. When the core takes an interrupt, the Machine Sub-Mode will be updated to interrupt handling mode, so:</p>
<ul>
<li>The value of msubm.PTYP will be updated to the value of msub.TYP before taking the interrupt as shown in Figure 54. The value of msubm.PTYP will be used to restore the value of msubm.PTYP after exiting the interrupt handler.</li>
<li>The filed msubm.TYP is updated to interrupt handling mode, as described in Figure 5-4, to reflect the current Machine Sub-Mode is &#x201C;interrupt handling mode&#x201D;.</li>
</ul>
<h3 id="564-update-the-csr-mepc"><strong>5.6.4. Update the CSR mepc</strong><div id="5-6-4"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The return address when the Bumblebee Core exit the interrupt handler is stored in the CSR mepc. When the core takes an interrupt, the hardware will update the CSR mepc automatically, and the value in this CSR will be the return address when exit the interrupt handler. After handling the interrupt, the PC value is restored from this CSR to return to the execution point that was previously stopped.</p>
<p>Note&#xFF1A;</p>
<ul>
<li>When an interrupt is taken, the CSR mepc is updated to the PC of the instruction that encounters the interrupt. Then after exiting the interrupt, the program will continue to execute from the instruction that encounters the interrupt.</li>
<li>Although the CSR mepc can be updated automatically encountering an interrupt, it is a both readable and writeable register, so the software can modify it explicitly.</li>
</ul>
<h3 id="565-update-the-csrs-mcause-and-mstatus"><strong>5.6.5. Update the CSRs mcause and mstatus</strong><div id="5-6-5"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The format of the CSR mcause is shown in Table 7-6. The Bumblebee Core will update the CSR mcause by the hardware automatically when take a trap, as shown in Figure 5-4, as follows:</p>
<ul>
<li>A mechanism is required to record the ID of the interrupt being taken.<ul>
<li>When an interrupt is taken by the Bumblebee Core, the field mcause.EXCCODE is updated to the ID of the taken interrupt by the ECLIC, so the software can query the ID of this selected interrupt by reading this register.</li>
</ul>
</li>
<li>The current interrupt is taken, possibly preempting the interrupt was previously being processed (whose interrupt level is relatively lower, so it can be preempted), and a mechanism is needed to record the interrupt level of the preempted interrupt.<ul>
<li>When an interrupt is taken by the Bumblebee Core, the field mcause.MPIL is updated to the value of minstatus.MIL. The value of mcause.MPIL is used to restore the value of mcause.MIL after handling the interrupt.</li>
</ul>
</li>
<li>The current interrupt is taken, a mechanism is required to record the global interrupt enable bit and the Privilege Mode before taking the interrupt.<ul>
<li>When the Bumblebee Core takes an interrupt, the filed mstatus.MPIE will be updated to the value of mstatus.MIE, and the filed mstatus.MIE will be set to 0, which means interrupts are globally masked, and all interrupts will not be taken.</li>
<li>When the Bumblebee Core takes an interrupt, the Privilege Mode of the core will be switched to Machine Mode, and the field mstatus.MPP will be set to the Privilege Mode before taking the interrupt.</li>
</ul>
</li>
<li>If the taken interrupt is a vectored interrupt, the core will jump to the corresponding target address stored in the Vector Table Entry. For a detailed description of the vectored interrupt processing mode, please see Section 5.13.2. In terms of the hardware implementation, the processing of an interrupt needs to be divided into two steps. The first step is to query the target address from the Vector Table, and then jump to the target address in the second step. Then, it is possible that a memory access occurs in the first step, querying the target address from the Vector Table, so a mechanism is required to record such a special memory access error.<ul>
<li>When the Bumblebee Core takes an interrupt, if the interrupt is a vectored mode interrupt, the value of mcause.minhv will be updated to 1, and then cleared to 0 when the above &#x201C;two-step&#x201D; operation is completed. Assuming a memory access error occurs midway, it will raise an Instruction Access Fault exception, and the value of mcause.minhv will be 1 assuming this bit is not cleared.&#x3002;</li>
</ul>
</li>
<li>Note: the fields mcause.MPIE and mcause.MPP are mirrored with the fields mstatus.MPIE and mstatus.MPP. Which means normally the value of mstatus.MPIE is always the same as the value of mcause.MPIE and the value of mstatus.MPP is the same as the value of mcasue.MPP.&#x3002;</li>
</ul>
<p><img src="chapter5/5.6/5.6.5.assets/11.png" alt=""></p>
<p>&#x200B;                                                       <strong><center>Figure 5-4 The CSR updating when enter/exit the Interrupt</center></strong></p>
<h2 id="57exit-the-interrupt-handling-mode"><strong>5.7.Exit the Interrupt Handling Mode</strong><div id="5-7"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;After handling the interrupt, the core needs to exit from the interrupt handler eventually, and return to execute the main program. Since the interrupt is handling in Machine Mode, the software has to execute mret to exit the interrupt handler. The hardware behavior of the processor after executing mret instruction is as follows. Note that the following hardware behaviors are done simultaneously in one cycle:</p>
<ul>
<li>Stop the execution of the current program, and start from the PC address defined by the CSR mepc.</li>
<li>Update the following CSRs as shown in Figure 5-4&#xFF1A;<ul>
<li>mstatus&#xFF08;Machine Status Register&#xFF09;</li>
<li>mcause&#xFF08;Machine Cause Register&#xFF09;</li>
<li>mintstatus&#xFF08;Machine Interrupt Status Register&#xFF09;</li>
</ul>
</li>
<li>Update the Privilege Mode and the Machine Sub-Mode&#x3002;
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The overall process of exiting an NMI is shown in Figure 5-5.
<img src="chapter5/5.7/5.7.assets/12.png" alt=""></li>
</ul>
<p>&#x200B;                                                             <strong><center>Figure 5-5 The overall process of exiting an interrupt</center></strong></p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;These will be detailed in the following parts.</p>
<h3 id="571-executing-from-the-address-defined-by-mepc"><strong>5.7.1. Executing from the Address Defined by mepc</strong><div id="5-7-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When an interrupt is taking, the mepc is updated to the PC value of the instruction encountered the interrupt. Through this mechanism, executing the mret instruction, the core will return to the instruction encountered the interrupt, and continue to execute the program.</p>
<h3 id="572-update-the-csrs-mcause-and-mstatus"><strong>5.7.2. Update the CSRs mcause and mstatus</strong><div id="5-7-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The format of the CSR mcause is shown in Table 7-6. The Bumblebee Core will update the CSR mcause when executes one mret instruction, as follows:</p>
<ul>
<li>When an interrupt is taken, the value of mcause.MPIL will be updated to the value of mintstatus.MIL before taking the interrupt. The hardware will restore the value of minstatus.MIL using the value of mcause.MPIL when executes the mret instruction to exit the interrupt handler. Through this mechanism, the value of mintstatus.MIL is restored to the previous value before taking the interrupt.</li>
<li>When an interrupt is taken, the value of mcause.MPIE will be updated to the value of mintstatus.MIE before taking the interrupt. The hardware will restore the value of minstatus.MIE using the value of mcause.MPIE when executes the mret instruction to exit the interrupt handler. Through this mechanism, the value of mintstatus.MIE is restored to the previous value before taking the interrupt.</li>
<li>When an interrupt is taken, the value of mcause.MPP will be updated to the Privilege Mode before taking the interrupt. The hardware will restore the Privilege Mode using the value of mcause.MPP when executes the mret instruction to exit the interrupt handler. Through this mechanism, the Privilege Mode is restored to the previous value before taking the interrupt.
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;- Note: the fields mcause.MPIE and mcause.MPP are mirrored with the fields mstatus.MPIE and mstatus.MPP. Which means normally the value of mstatus.MPIE is always the same as the value of mcause.MPIE and the value of mstatus.MPP is the same as the value of mcasue.MPP.</li>
</ul>
<h3 id="573-update-the-privilege-mode"><strong>5.7.3. Update the Privilege Mode</strong><div id="5-7-3"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The hardware will update the Privilege Mode using the value of mcause.MPP automatically after the execution of the mret instruction:</p>
<ul>
<li>Taking an interrupt, the value of mstatus.MPP was updated to the Privilege Mode of the core before taking the interrupt, and after executing the mret instruction, the value of Privilege Mode is restored by the value of mstatus.MPP. Through this mechanism, the core is guaranteed to return to the Privilege Mode before taking the interrupt. </li>
</ul>
<h3 id="574-update-the-machine-sub-mode"><strong>5.7.4. Update the Machine Sub-Mode</strong><div id="5-7-4"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The value of msubm.TYP indicates the Machine Sub-Mode of the Bumblebee Core in real time. After executing the mret instruction, the hardware will automatically restore the core&#x2019;s Machine Sub-Mode by the value of msubm.PTYP:</p>
<ul>
<li>Taking an interrupt, the value of msubm.PTYP is updated to the Machine Sub-Mode before taking the interrupt. After executing the mret instruction, the hardware will automatically restore the Machine Sub-Mode using the value of msubm.PTYP. Through this mechanism, the Machine Sub-Mode of the core is restored to the same mode before taking the interrupt.</li>
</ul>
<h2 id="58-interrupt-vector-table"><strong>5.8. Interrupt Vector Table</strong><div id="5-8"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As shown in Figure 56, the interrupt vector table is an contiguous address space in the memory, and each word of this address space is used to store the address of the interrupt service routine corresponding to each interrupt source of the ECLIC.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The base address of the interrupt vector table is defined by the CSR mtvt. Typically, the value of mtvt can be set to the beginning of the entire code segment.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The role of the interrupt vector table is very important. When the core takes an interrupt, no matter a vectored or non-vectored interrupt, the hardware will eventually jump to the corresponding PC of the interrupt service routine by querying the interrupt vector table. Please see Section 5.13 for more details.&#x3002;</p>
<p><img src="chapter5/5.8.assets/13.png" alt=""></p>
<p>&#x200B;                                                                 <strong><center>Figure 5-6 Interrupt Vector Table</center></strong></p>
<h2 id="59-context-saving-and-restoring"><strong>5.9. Context Saving and Restoring</strong><div id="5-9"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Processors based on the RISC-V architecture do not support the hardware automatic context saving and restoring when take or exit an interrupt. So the software is required to write the instructions (in assembly language) for context saving and restoring. Depending on whether the interrupt is a vectored or non-vectored, the context requiring saving and restoring will vary. Please see Section 5.13 for more details.</p>
<h2 id="510-interrupt-response-latency"><strong>5.10. Interrupt Response Latency</strong><div id="5-10"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The concept of interrupt response latency usually refers to the cycle consumed from the time point &#x201C;external interrupt source pull-up&#x201D; to the time point &#x201C;the first instruction in the corresponding interrupt service routine is executed&#x201D;. Therefore, the interrupt latency usually includes the following aspects of the cycle overhead:</p>
<ul>
<li>The overhead of jumping to the target PC</li>
<li>The overhead of context saving</li>
<li>The overhead of jumping to the Interrupt Service Routine</li>
</ul>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Interrupt response latency varies depending on whether the interrupt is a vectored or non-vectored. Please see Section 5.13 for more details.</p>
<h2 id="511-interrupt-preemption"><strong>5.11. Interrupt Preemption</strong><div id="5-11"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;While the core is handling an interrupt, there may be another new interrupt request of a higher level, and then the core can stop the current interrupt service routine and start to taken the new one and execute its &#x201C;Interrupt Service Routine&#x201D;. Hence, the interrupt preemption is formed (that is, the previous interrupt has not returned yet, and the new interrupt is taken), and there could be multi-level of preemptions.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Take the example in Figure 5-7 as an example:</p>
<ul>
<li>Assuming that the core is handling one timer interrupt and suddenly an interrupt is initiated by button 1 and this interrupt has a higher level than the timer interrupt. The core will stop processing the timer interrupt and start to handle the interrupt initiated by button 1.</li>
<li>Then another interrupt is initiated by button 2, which has a higher level than the interrupt initiated by button 1, so the core will stop processing the interrupt of button 1 and start to handle the interrupt of button 2.</li>
<li>After that no other higher-level interrupts arrive, the button 2 interrupt will not be preempted, and the core can successfully complete the interrupt service routine of the button 2 interrupt, and then return to process the button 1 interrupt.</li>
<li>Completing the interrupt service routine of button 1 interrupt, the core will return to execute the timer interrupt service routine to handle the timer interrupt.</li>
</ul>
<p><img src="chapter5/5.11.assets/14.png" alt=""></p>
<p>&#x200B;                                                                    <strong><center>Figure 5-7 Interrupt Preemption</center></strong></p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Note&#xFF1A;Assuming that the new coming interrupt request has not higher level than the handling interrupt, then the core should not take the request immediately. The core must complete the current interrupt service routine before take the new one. Please see Section 6.2.9 for more details.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;In the Bumblebee Core, the supported method for interrupt preemption depending on whether the interrupt is a vectored interrupt or a non-vectored interrupt. Please see Section 5.13 for more details.</p>
<h2 id="512-interrupt-tail-chaining"><strong>5.12. Interrupt Tail-Chaining</strong><div id="5-12"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;While the core is processing one interrupt, a new interrupt request is initiated, but the level of the new request is not higher than the handling one, so the new interrupt request cannot preempt the handling one.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;After handling the current interrupt, it is necessary to restore the context theoretically. Then exit the interrupt service routine and return to the main program and take the new interrupt. To take the new interrupt, it is necessary to save the context again. Therefore, there is a back-to-back &#x201C;context saving&#x201D; and &#x201C;context restoring&#x201D;. The &#x201C;tail-chaining&#x201D; can save the cost of this back-to-back &#x201C;context saving&#x201D; and &#x201C;context-restoring&#x201D;, as shown in the Figure 5-8.</p>
<p><img src="chapter5/5.12.assets/15.png" alt=""></p>
<p>&#x200B;                                                                 <strong><center>Figure 5-8  Interrupt tail-chaining</center></strong></p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As for the Bumblebee Core, only non-vectored interrupts support the operation of tail-chaining. Please see Section 5.13 .1.1 for more details.</p>
<h2 id="513-vectored-and-non-vectored-processing-mode-of-interrupts"><strong>5.13. Vectored and Non-Vectored Processing Mode of Interrupts</strong><div id="5-13"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As described in Section6.2.10, each interrupt source can be configured to vectored or non-vectored processing mode (via the shv field of the register clicinattr[i]). There is obvious difference between the vectored and non-vector processing mode, which are described in the following part.</p>
<h3 id="5131-non-vectored-processing-mode"><strong>5.13.1. Non-Vectored Processing Mode</strong><div id="5-13-1"></div></h3>
<h4 id="51311-feature-and-latency-of-non-vectored-processing-mode"><strong>5.13.1.1 Feature and Latency of Non-Vectored Processing Mode</strong><div id="5-13-1-1"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;If the interrupt is non-vectored, once it is taken, the core will jump to the common base entry shared by all non-vectored interrupts, and the address of this entry can be set by software:</p>
<ul>
<li>If the least significant bit of the CSR mtvt2 is 0 (power-on reset default value), the common base address shared by all non-vectored interrupts is specified by the CSR mtvec (ignoring the value of the lowest 2 bits). Since the CSR mtvec also indicates the entry address of exceptions, which means exceptions and all non-vector interrupts share the entry address.</li>
<li>If the least significant bit of the CSR mtvt2 is 1, the common entry address of all non-vectored interrupts is defined by the CSR mtvt2 (ignoring the value of the lowest 2 bits). In order to handle the interrupt as fast as possible, it is recommended to set the least significant bit of the CSR mtvt2 to 1, which means the entry address for all non-vectored interrupts is separated from the entry of exceptions which is defined by the CSR mtvec.</li>
<li>After entering the common base entry of non-vectored interrupts, the core will start to execute a common program, as the example shown in Feature 5-9, the program is typically as follows:</li>
<li>Firstly, save the CSR mepc, mcause, msubm into the stack. These CSR registers are saved to ensure that subsequent preempted interruption can be handled correctly, because taken the new interrupt will overwrite the values of mepc, mcause, msubm, so they need to be saved into the stack first.</li>
<li>Save several general-purpose registers (the execution context) into the stack.</li>
<li><p>Then execute a self-defined instruction &#x201C;csrrw ra, CSR_JALMNXTI, ra&#x201D;. If there is no pending interrupt, then this instruction will be regarded as a Nop. If there is a pending interrupt, the core will take the following operations:</p>
<ul>
<li>Jump to the target address stored in Vector Table Entry and execute the corresponding Interrupt Service Routine.</li>
<li>The hardware will set the global interrupt enable bit mstatus.MIE while the core jump to the interrupt service routine. Setting the mstatus.MIE bit, new interrupt will be taken and form an interrupt preemption.</li>
<li>In addition to jump to the Interrupt Service Routine, the instruction &#x201C;csrrw ra, CSR_JALMNXTI, ra&#x201D; also generate the effect of a JAL (Jump and Link) instruction. The hardware will update the value of the link register to the PC of this instruction as the return address of the function. Therefore, returning from the interrupt handler, the core will return to the instruction &#x201C;csrrw ra, CSR_JALMNXTI, ra&#x201D;, and re-judge whether there is still an interrupt pending to implement the operation of the tail-chaining.</li>
<li>At the end of the interrupt service routine, the software also needs to add the corresponding context saving and restoring operation. Before restoring the CSR mepc, mcause, msubm, the global interrupt enable bit mstatus.mie needs to be cleared again to ensure the atomicity of the recovery operations of mecp, mcause, and msubm.</li>
</ul>
</li>
</ul>
<p><img src="chapter5/5.13/5.13.1/5.13.1.1.assets/16.png" alt=""></p>
<p>&#x200B;                                                <strong><center>Figure 5-9 Example for non-vectored interrupt  </center></strong></p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Since the core need to execute a common handler before jump to the specified interrupt service routine of the corresponding non-vector interrupt. Therefore, the cycle overhead from the interrupt is initiated to the first instruction in the interrupt service routine is executed are caused by the followings:</p>
<ul>
<li>The overhead caused by jumping to the interrupt handler which is about 4 cycles ideally.</li>
<li>The overhead caused by saving CSRs mepc, mcause, msubm into the stack.</li>
<li>The overhead caused by saving the context. If the architecture is RV32E, then it only takes 8 cycles to save 8 general purpose registers; if it is RV32I architecture, then there are 16 general purpose registers required to be saved.</li>
<li>The overhead caused by jumping to the Interrupt Service Routine which is about 5 cycles ideally.</li>
</ul>
<h4 id="51312-preemption-of-non-vectored-interrupt"><strong>5.13.1.2 Preemption of Non-Vectored Interrupt</strong><div id="5-13-1-2"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As mentioned above, non-vectored interrupt processing mode can always support interrupt preemption as the example shown in Figure 5-10: assuming that the three interrupts 30, 31, 32 come sequentially, and the level of interrupt 32 is greater than the level of interrupt 31 which is greater than the level of interrupt 30. Since then, the subsequent interrupts will preempt interrupts that were previously processed to form interrupt preemptions</p>
<p><img src="chapter5/5.13/5.13.1/5.13.1.2.assets/17.png" alt=""></p>
<p>&#x200B;                                         <strong><center>Figure 5-10Interrupt preemptions caused by three sequential non-vectored interrupts</center></strong></p>
<h4 id="51313-non-vectored-interrupt-tail-chaining"><strong>5.13.1.3 Non-Vectored Interrupt Tail-Chaining</strong><div id="5-13-1-3"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;For non-vectored interrupts, the tail-chaining can save cycles overhead significantly (saving one back-to-back context saving and restoring) since the core has to save and restore the context when entering and exiting the interrupt service routine.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As mentioned above, in addition to jump to the interrupt service routine, the instruction &#x201C;csrrw ra, CSR_JALMNXTI, ra&#x201D; in the common base handler shared by all non-vectored interrupts also achieves the effect of JAL (Jump and Link) which means the hardware will update the value of the Link register to the PC of this instruction as the return address. Therefore, the core will execute the instruction &#x201C;csrrw ra, CSR_JALMNXTI, ra&#x201D; again when it exits the interrupt service handler and re-judge if there is a pending interrupt to perform the tail-chaining operation.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As the example shown in Figure 511: assuming the interrupts 30, 29, 28 come successively, and &#x201C;the level of interrupt 30 &#x201D; &gt;= &#x201C;the level of interrupt 29&#x201D; &gt;= &#x201C;the level of interrupt 28&#x201D;, then the subsequent interrupt will not preempt the interrupt that was taken before which means no preemption will happen, but all these subsequent interrupt will be marked as &#x201C;pending&#x201D;. When the interrupt 30 has been already handled, the core will handle the interrupt 29 directly without the intermediate &#x201C;context restoring&#x201D; and &#x201C;context saving&#x201D; procedures.</p>
<p><img src="chapter5/5.13/5.13.1/5.13.1.3.assets/18.png" alt=""></p>
<p>&#x200B;                                                              <strong><center>Figure5-11 Interrupt tail-chaining</center></strong></p>
<h3 id="5132-vectored-processing-mode"><strong>5.13.2. Vectored Processing Mode</strong><div id="5-13-2"></div></h3>
<h4 id="51321-feature-and-latency-of-vectored-processing-mode"><strong>5.13.2.1 Feature and Latency of Vectored Processing Mode</strong><div id="5-13-2-1"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;If the interrupt is vectored, once it is taken, the core will jump to the target address saved in the Vector Table Entry directly, which is the corresponding interrupt service routine of the interrupt, as shown in Feature 5-12.</p>
<p><img src="chapter5/5.13/5.13.2/5.13.2.1.assets/19.png" alt=""></p>
<p>&#x200B;                                                             <strong><center>Figure 5-12 Example for vectored interrupt</center></strong></p>
<p>Vectored Processing Mode has the following features&#xFF1A;</p>
<ul>
<li>The core will jump directly to the interrupt service routine without context saving and restoring. Therefore, the latency of the vectored interrupt is very short. Ideally, it only takes 6 cycles from the interrupt initiation to the execution of the first instruction of the interrupt service routine, because the hardware only need to perform one lookup and jump.</li>
<li>pt service routine of a vectored interrupt, the indication&#x201D; <strong>attribute</strong> ((interrupt))&#x201D; is required to indicate this program is an interrupt service routine.
-In the vector processing mode, since the core does not save the context before jumping to the interrupt service routine, theoretically the interrupt handler cannot call any subfunction which means the handler must be a leaf function.</li>
<li>In the vector processing mode, since the core does not save the context before jumping to the interrupt service routine, theoretically the interrupt handler cannot call any subfunction which means the handler must be a leaf function.<ul>
<li>If the interrupt service routine accidentally calls another subfunction, which means the routine is not a leaf function, it will cause a function error without special processing. In order to avoid this accidental error, as long as the indication &#x201C;<strong>attribute</strong> ((interrupt))&#x201D; is used to indicate this function is an interrupt handler, the compiler will automatically detect if this function calls any subfunction. If it calls any subfunction, the compiler will automatically insert a piece of code to save the context. Note: in this case, although the function correctness is guaranteed, the overhead caused by context saving will actually increase the latency of the response of the interrupt (equivalent to the non-vectored interrupt processing) and cause the expansion of the code size. Hence, in practice, it is not recommended to call other subfunctions in the interrupt service routine of a vectored interrupt.</li>
<li>In vector processing mode, the core does not perform any special operation before jumping to the interrupt service routine, and the value of mstatus.mie is updated to 0 by the hardwire which means the interrupt is global disabled and no new interrupt will be taken once the core is handling the interrupt. Therefore, the vectored processing mode does not support interrupt preemption by default. In order to support vectored interrupt preemption, a special stack-push operation is necessary at the beginning of the interrupt service routine as shown in Figure 5-13:</li>
<li>First save the CSRs mepc, mcause, msubm to the stack. These CSRs are saved to ensure that subsequent interrupt preemption can perform correctly, because the new taken interrupt will overwrite the values of mepc, mcause, and msubm, so they need to be saved to the stack first.</li>
<li>Re-enable the global interrupt enable bit, that is, set the MIE filed of the CSR mstatus to 1. After the global interrupt enable bit is set, the new interrupt can be taken to implement the mechanism of interrupt preemption.</li>
<li>At the end of the interrupt service routine, it is necessary to add the operation of context restoring. And before CSRs mepc, mcause, and msubm are restored from the stack, the global interrupt enable bit must be 0 to provide the atomicity of the restoring operation of CSRs mepc, mcause, and msubm (not interrupted by the new interrupt).</li>
</ul>
</li>
</ul>
<p><img src="chapter5/5.13/5.13.2/5.13.2.1.assets/20.png" alt=""></p>
<p>&#x200B;                                                     <strong><center>Figure 5-13 Example for vectored interrupt supported preemption</center></strong></p>
<h4 id="51322-preemption-of-vectored-interrupt"><strong>5.13.2.2 Preemption of Vectored Interrupt</strong><div id="5-13-2-2"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As described above, with the special processing, the vectored processing mode can support interrupt preemption, as shown in Figure 514: assuming that the three interrupts 30, 31, 32 come sequentially, and the level of interrupt 32 is greater than the level of interrupt 31 which is greater than the level of interrupt 30. Since then, the subsequent interrupts will preempt interrupts that were previously processed to form interrupt preemptions.</p>
<p><img src="chapter5/5.13/5.13.2/5.13.2.2.assets/21.png" alt=""></p>
<p>&#x200B;                                            <strong><center>Figure 5-14 Interrupt preemptions caused by three sequential vectored interrupts</center></strong></p>
<h4 id="51323-vectored-interrupt-tail-chaining"><strong>5.13.2.3 Vectored Interrupt Tail-Chaining</strong><div id="5-13-2-3"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;For the vectored interrupt, the core does not save the context before jumping to the interrupt service routine, so the meaning of &#x201C;interrupt tail- chaining&#x201D; is not significant. Therefore, the vector interrupt does not support the operation of &#x201C;interrupt tail-chaining&#x201D;.</p>
<h1 id="6-6the-timer-and-the-eclic-unit-of-the-bumblebee-core"><strong>6. 6.The TIMER and the ECLIC Unit of the Bumblebee Core</strong><div id="6"></div></h1>
<h2 id="61-introduction-of-the-timer-unit"><strong>6.1. Introduction of the TIMER Unit</strong><div id="6-1"></div></h2>
<h3 id="611-timer-introduction"><strong>6.1.1. TIMER Introduction</strong><div id="6-1-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Timer Unit (TIMER) is used to generate the Timer Interrupt and Software Interrupt in the Bumblebee Core. Please see Section 5.3.2.1 and Section 5.3.2.2 for more details about the Timer Interrupt and the Software Interrupt. </p>
<h3 id="612timer-registers"><strong>6.1.2.TIMER Registers</strong><div id="6-1-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The TIMER is a memory-mapped unit:</p>
<ul>
<li>For the base address of the TIMER unit, please refer to the Datasheet of the Bumblebee Core.</li>
<li>Registers and the corresponding offset in the TIMER unit are shown in Table 6-1.</li>
</ul>
<p>&#x200B;                                                <strong><center>Table 6-1 The mapped address of registers in the TIMER unit</center></strong></p>
<table>
<thead>
<tr>
<th>Offset inside the Unit</th>
<th>Accessibility</th>
<th>Register</th>
<th>Value by Default</th>
<th>Function Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0</td>
<td>RW</td>
<td>mtime_lo</td>
<td>0x00000000</td>
<td>Reflect the lower 32-bit value of mtime,. Please refer to Section 6.1.3 for details.</td>
</tr>
<tr>
<td>0x4</td>
<td>RW</td>
<td>mtime_hi</td>
<td>0x00000000</td>
<td>Reflect the upper 32-bit value of mtime. Please refer to Section 6.1.3 for details.</td>
</tr>
<tr>
<td>0x8</td>
<td>RW</td>
<td>mtimecmp_lo</td>
<td>0xFFFFFFFF</td>
<td>Set the lower 32-bit value of mtimecmp,. Please refer to Section 6.1.5 for details.</td>
</tr>
<tr>
<td>0xC</td>
<td>RW</td>
<td>mtimecmp_hi</td>
<td>0xFFFFFFFF</td>
<td>Set the upper 32-bit value of mtimecmp,. Please refer to Section 6.1.5 for details.</td>
</tr>
<tr>
<td>0xFF8</td>
<td>RW</td>
<td>mstop</td>
<td>0x00000000</td>
<td>Used to pause the time counter. Please refer to Section 6.1.4 for details.</td>
</tr>
<tr>
<td>0xFFC</td>
<td>RW</td>
<td>msip</td>
<td>0x00000000</td>
<td>Used to generate the Software Interrupt. Please refer to Section 6.16 for details.</td>
</tr>
</tbody>
</table>
<p>Note&#xFF1A;</p>
<ul>
<li>Registers in the TIMER unit only support aligned read and write access with a size of a word.</li>
<li>The address space range of registers in the TIMER unit is 0x00 ~ 0xFF. The value in the address other than the registers listed in the above table is constant 0.</li>
</ul>
<p>The function and use of each register are described in detail in the following parts herein.</p>
<h3 id="613-time-counter-register-mtime"><strong>6.1.3. Time Counter Register mtime</strong><div id="6-1-3"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The TIMER unit can be used for real-timing timing, the key points are as follows:</p>
<ul>
<li>The TIMER implements a 64-bit register mtime, which is composed of {mtime_hi, mtime_lo}. This register reflects the value of the 64-bit timer. The timer increments according to the low-speed input beat signal. The timer is turned on by default, so it will always count.</li>
<li>In the Bumblebee Core, the increment frequency of the counter is controlled by the input signal mtime_toggle_a, which is the input signal of the core. Please refer to the Datasheet for Bumblebee Processor Core for details about this signal.</li>
</ul>
<h3 id="614-pause-the-timer-counter-through-mstop"><strong>6.1.4. Pause the Timer Counter through mstop</strong><div id="6-1-4"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Since the timer of the TIMER unit is automatically incremented by default after reset, in order to turn off this timer count for some special cases, the register mstop is implemented. As shown in Table 62, only the least significant bit of mstop register is an effective bit, and this bit is used to pause the timer. Therefore, the software can pause the timer by setting the LSB of mstop to 1.</p>
<p>&#x200B;                                                    <strong><center>Table 6-2 mstop bit assignments</center></strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Bits</th>
<th>Accessibility</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved</td>
<td>7:1</td>
<td>Readable, write ignored</td>
<td>N/A</td>
<td>Reserved, ties to 0</td>
</tr>
<tr>
<td>TIMESTOP</td>
<td>0</td>
<td>RW</td>
<td>0</td>
<td>Control the timer count or pause. If this field is 1, then the timer is paused, otherwise it increments normally.</td>
</tr>
</tbody>
</table>
<h3 id="615generate-the-timer-interrupt-through-mtime-and-mtimecmp"><strong>6.1.5.Generate the Timer Interrupt through mtime and mtimecmp</strong><div id="6-1-5"></div></h3>
<p>The TIMER unit can be used to generate the timer interrupt, the key points are as follows:
  The TIMER implements a 64-bit register mtimecmp, which is composed of {mtimecmp_hi, mtimecmp_lo}. This register is used as the comparison value of the timer. If the value of mtime is greater than the value of mtimecmp, then a timer interrupt is generated. The software can clear the timer interrupt by overwriting the value of mtimecmp or mtime (so that the value of mtimecmp is greater than the value of mtime).</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Note: the timer interrupt is connected to the ECLIC unit for unified management. Please see Section 6.2 for details on the ECLIC unit.</p>
<h3 id="616-generating-the-software-interrupt-through-msip"><strong>6.1.6. Generating the Software Interrupt through msip</strong><div id="6-1-6"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The TIMER unit can be used to generate the Software Interrupt. The register msip is implemented in the TIMER unit. As shown in Table 6-3, only the least significant bit of msip is an effective bit. This bit is used to generate the software interrupt directly:</p>
<ul>
<li>The software generates the software interrupt by writing 1 to the msip register;</li>
<li>The software clears the software interrupt by writing 0 to the msip register.</li>
</ul>
<p>Note: the soft interrupt is connected to the ECLIC unit for unified management. Please see Section 6.2 for details on the ECLIC unit.</p>
<p>&#x200B;                                                    <strong><center>Table 6-3 msip bit assignments</center></strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Bits</th>
<th>Accessibility</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved</td>
<td>7:1</td>
<td>Readable, write ignored</td>
<td>N/A</td>
<td>Reserved, ties to 0</td>
</tr>
<tr>
<td>MSIP</td>
<td>0</td>
<td>RW</td>
<td>0</td>
<td>This bit is used to generate the software interrupt</td>
</tr>
</tbody>
</table>
<h2 id="62-the-eclic-unit"><strong>6.2. The ECLIC Unit</strong><div id="6-2"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core supports the Enhanced Core Local Interrupt Controller (ECLIC), which is optimized based on the RISC-V standard CLIC, to manage all interrupt sources.</p>
<p>Note&#xFF1A;</p>
<ul>
<li>The ECLIC unit only serves one core and is private to the core.</li>
<li>The ECLIC&#x2019;s software programming model is backward compatible with standard CLIC.</li>
</ul>
<h3 id="621-introduction-of-the-eclic-unit"><strong>6.2.1. Introduction of the ECLIC unit</strong><div id="6-2-1"></div></h3>
<p><img src="chapter6/6.assets/22.png" alt=""></p>
<p>&#x200B;                                                                <strong><center>Figure6-1 The struct of the ECLIC unit</center></strong></p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The ECLIC unit is used to arbitrate multiple internal and external interrupts, send request and support the interrupt preemption. The registers of the ECLIC are described in Table 6-5, and its structure is shown in Figure 6-1 and the related concepts are as follows:</p>
<ul>
<li>ECLIC interrupt target</li>
<li>ECLIC interrupt source</li>
<li>ECLIC interrupt source ID</li>
<li>ECLIC registers</li>
<li>ECLIC interrupt enable bits</li>
<li>ECLIC interrupt pending bits</li>
<li>ECLIC interrupt level or edge triggered attribute</li>
<li>ECLIC interrupt level and priority</li>
<li>ECLIC interrupt vectored or non-vectored processing mode</li>
<li>ECLIC interrupt threshold level</li>
<li>ECLIC interrupt arbitration mechanism</li>
<li>ECLIC interrupt response, preemption, tail-chaining mechanism</li>
</ul>
<p>These will be detailed below.</p>
<h3 id="622eclic-interrupt-target"><strong>6.2.2.ECLIC interrupt target</strong><div id="6-2-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The ECLIC unit link the interrupt source to the processor core (as the interrupt target) by a line as shown in Figure 6-2.</p>
<p><img src="chapter6/6.assets/23.png" alt=""></p>
<p>&#x200B;                                                                <strong><center>Figure 6-2 ECLIC Relationship  structure</center></strong></p>
<h3 id="623-eclic-interrupt-source"><strong>6.2.3. ECLIC Interrupt Source</strong><div id="6-2-3"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As shown in Figure 6-2, the ECLIC unit can support up to 4096 interrupt sources. The ECLIC unit has defined the following features and parameters of each interrupt source:</p>
<ul>
<li>ID</li>
<li>IE</li>
<li>IP</li>
<li>Level or Edge-Triggered</li>
<li>Level and Priority</li>
<li>Vector or Non-Vector Mode</li>
</ul>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;These will be detailed below.</p>
<h3 id="624eclic-interrupt-source-id"><strong>6.2.4.ECLIC Interrupt Source ID</strong><div id="6-2-4"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The ECLIC unit has assigned a unique ID to each interrupt source. For example, if a hardware implementation of the ECLIC unit really configured to support 4096 IDs, then the ID should be 0 to 4095. Note:</p>
<ul>
<li>In the Bumblebee core, the interrupt IDs ranged from 0 to 18 are reserved for the core-specified internal interrupts.</li>
<li>The interrupt source ID greater than 18 can be used by the user to bind to external interrupt sources.</li>
</ul>
<p>The details are shown in Table 64.</p>
<p>&#x200B;                                                  <strong><center>Table 6-4 ECLIC interrupt sources and assignment</center></strong></p>
<table>
<thead>
<tr>
<th>ECLIC interrupt ID</th>
<th>Function</th>
<th>Interrupt Source Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>1</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>2</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>3</td>
<td>Software interupt</td>
<td>The software interrupt generated by the TIMER</td>
</tr>
<tr>
<td>4</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>5</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>6</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>7</td>
<td>Timer interupt</td>
<td>The software interrupt generated by the TIMER</td>
</tr>
<tr>
<td>8</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>9</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>10</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>11</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>12</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>13</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>14</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>15</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>16</td>
<td>Reserved</td>
<td>BThis source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>17</td>
<td>The memory access error is defined as an internal interrupt in the Bumblebee core</td>
</tr>
<tr>
<td>18</td>
<td>Reserved</td>
<td>This source is not used in the Bumblebee Core</td>
</tr>
<tr>
<td>19~4095</td>
<td>External interrupt</td>
<td>Normal external interrupt defined by users.</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p> Note:</p>
<ul>
<li>Although the ECLIC unit can support up to 4096 interrupt sources from the programming mode, the actual number of supported interrupt sources is indicated in the field clicinfo.NUM_INTERRUPT.&#x3002;  </li>
</ul>
<h3 id="625-eclic-registers"><strong>6.2.5. ECLIC Registers</strong><div id="6-2-5"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The ECLIC is a memory-mapped unit.</p>
<ul>
<li>The base address of the ECLIC unit in the Bumblebee Core is introduced in the Datasheet for Bumblebee Processor Core.</li>
<li>The registers and their corresponding offset addresses in the ECLIC unit are shown in Table 6-5.</li>
</ul>
<p>&#x200B;                                                  <strong><center>Table 6-5ECLIC registers memory map</center></strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Accessibility</th>
<th>Register</th>
<th>Width</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0000</td>
<td>RW</td>
<td>cliccfg</td>
<td>8-bit</td>
</tr>
<tr>
<td>0x0004</td>
<td>Readable, write ignored</td>
<td>clicinfo</td>
<td>32-bit</td>
</tr>
<tr>
<td>0x000b</td>
<td>RW</td>
<td>mth</td>
<td>8-bit</td>
</tr>
<tr>
<td>0x1000+4*i</td>
<td>RW</td>
<td>clicintip[i]</td>
<td>8-bit</td>
</tr>
<tr>
<td>0x1001+4*i</td>
<td>RW</td>
<td>clicintie[i]</td>
<td>8-bit</td>
</tr>
<tr>
<td>0x1002+4*i</td>
<td>RW</td>
<td>clicintattr[i]</td>
<td>8-bit</td>
</tr>
<tr>
<td>0x1003+4*i</td>
<td>RW</td>
<td>clicintctl[i]</td>
<td>8-bit</td>
</tr>
</tbody>
</table>
<p>Note&#xFF1A;</p>
<ul>
<li>The above &#x201C;i&#x201D; indicates the interrupt ID, an interrupt i has its own corresponding clicintip[i], clicintie[i], clicintattr[i], and clicintctl[i] registers.</li>
<li>ECLIC registers only support aligned access which is the size of byte, half-word or word.</li>
<li>The above &#x201C;R&#x201D; means read-only, and any write to this read-only register will be ignored without generating bus error.</li>
<li>The ELCIC unit may not be configured to support 4096 interrupt sources. If an input i is not present in the hardware, the corresponding clicintip[i], clicintie[i], clicintctl[i] memory locations appear hardwired to zero.
The address space of ECLIC registers is the range from 0x0000 to 0xFFFF. The value in an address other than the address listed in the above table is constant 0.</li>
</ul>
<p>These registers are detailed in the following part.</p>
<h4 id="6251-cliccfg"><strong>6.2.5.1 cliccfg</strong><div id="6-2-5-1"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;This cliccfg register is a global configuration register. The software can set global configurations by write this register. Table 6-6 describes the bit assignments of this register.</p>
<p>&#x200B;                                                <strong><center>Table 6-6  cliccfg bit assignments</center></strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Bits</th>
<th>Accessibility</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved</td>
<td>7:5</td>
<td>RO</td>
<td>N/A</td>
<td>Reserved, ties to 0.</td>
</tr>
<tr>
<td>nlbits</td>
<td>4:1</td>
<td>RW</td>
<td>0</td>
<td>Used to specified the bit-width of level and priority in the register clicintctl[i]. Please see Section 6.2.9 for more details.</td>
</tr>
<tr>
<td>Reserved</td>
<td>0</td>
<td>RO</td>
<td>N/A</td>
<td>Reserved, ties to 1.</td>
</tr>
</tbody>
</table>
<h4 id="6252-clicinfo"><strong>6.2.5.2 clicinfo</strong><div id="6-2-5-2"></div></h4>
<p>The clicinfo register is a global info register. The software can query the global parameters by reading this register. Table 6-7 describes the bit assignments of this register.</p>
<p>&#x200B;                                                <strong><center>Table 6-7clicinfo bit assignments </center></strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Bits</th>
<th>Accessibility</th>
<th>Default Value</th>
<th>Description]</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved</td>
<td>31:25</td>
<td>RO</td>
<td>N/A</td>
<td>Reserved, ties to 0.</td>
</tr>
<tr>
<td>CLICINTCTLBITS</td>
<td>24:21</td>
<td>RO</td>
<td>N/A</td>
<td>Used to specified the effective bit-width the register clicintctl[i]. Please see Section 6.2.9 for more details.</td>
</tr>
<tr>
<td>VERSION</td>
<td>20:13</td>
<td>RO</td>
<td>N/A</td>
<td>Hardware implementation version number.</td>
</tr>
<tr>
<td>NUM_INTERRUPT</td>
<td>12:0</td>
<td>RO</td>
<td>N/A</td>
<td>Number of interrupt sources supported by the hardware</td>
</tr>
</tbody>
</table>
<h4 id="6253-mth"><strong>6.2.5.3 mth</strong><div id="6-2-5-3"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mth register is used the set the target interrupt threshold level. The software can configure the target interrupt threshold level by writing this register. Table 6-8 describes the bit assignments of this register.</p>
<p>&#x200B;                                                  <strong><center>Table 6-8 mth bit assignments</center></strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Bits</th>
<th>Accessiblity</th>
<th>DefaultValue</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>mth</td>
<td>7:0</td>
<td>RW</td>
<td>N/A</td>
<td>Target interrupt threshold level register. Please see Section 6.2.9 for more details.</td>
</tr>
</tbody>
</table>
<h4 id="6254-clicintipi"><strong>6.2.5.4 clicintip[i]</strong><div id="6-2-5-4"></div></h4>
<p>The clicintip[i] register is the pending flag register for the interrupt source. Table 6-9 describes the bit assignments of this register.</p>
<p>&#x200B;                                             <strong><center>Table 6-9 clicintip[i] bit  assignments</center></strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Bits</th>
<th>Accessibility</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved</td>
<td>7:1</td>
<td>RO</td>
<td>N/A</td>
<td>Reserved, ties to 0</td>
</tr>
<tr>
<td>IP</td>
<td>0</td>
<td>RW</td>
<td>0</td>
<td>Interrupt source pending flag. Please see Section 6.2.7 for more details.</td>
</tr>
</tbody>
</table>
<h4 id="6255-clicintiei"><strong>6.2.5.5 clicintie[i]</strong><div id="6-2-5-5"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The clicintip[i] register is the pending flag register for the interrupt source. Table 6-10 describes the bit assignments of this register.</p>
<p>&#x200B;                                           <strong><center>Table 6-10 clicintip[i] bit assignments</center></strong></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Bits</th>
<th>Accessibility</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reserved</td>
<td>7:1</td>
<td>RO</td>
<td>N/A</td>
<td>Reserved,ties to 0</td>
</tr>
<tr>
<td>IE</td>
<td>0</td>
<td>RW</td>
<td>0</td>
<td>Interrupt enable bit.Please see Section 6.2.6 for more details</td>
</tr>
</tbody>
</table>
<h4 id="6256-clicintattrli"><strong>6.2.5.6 clicintattrl[i]</strong><div id="6-2-5-6"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The clicintattr[i] register is used to indicate the attribute of the interrupt source. The software can configure the attribute of the interrupt source by writing this register. Table 6-11 describes the bit assignments of this register.
   <strong><center>Table 6-11 clicintip[i] bits assignments</center></strong>
| Field     | Bits | Accessibility         | Default Vaule | Description                                          |
| -------- | ------ | ------------ | ------ | ------------------------------- |
| Reserved | 7:6    | RO | N/A    | Reserved, ties to 2&#x2019;b11        |
| Reserved | 5:3    | RO | N/A    | Reserved, ties to o        |
| trig | 2:1    |RW | o    | Used to configure the level or edge triggered attribute of the interrupt source. Please see Section 6.2.8 for more details.        |
| shv       | 0      | RW    | 0      | Used to configure whether the interrupt is vectored or non-vectored. Please see Section 6.2.10 for more details. |</p>
<h4 id="6257-clicintctli"><strong>6.2.5.7 clicintctl[i]</strong><div id="6-2-5-7"></div></h4>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The clicintctl[i] register is the control register of the interrupt source. The software can configure the level and priority by writing this register. The level and priority field are dynamically allocated based on the value of cliccfg.nlbits. Please see Section 6.2.9 for more details. </p>
<h3 id="626-eclic-interrupt-enable-bit-ie&#xFF09;"><strong>6.2.6. ECLIC Interrupt Enable Bit (IE&#xFF09;</strong><div id="6-2-6"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As shown in Figure 6-2, the ECLIC unit has allocated an interrupt enable bit (IE) for each interrupt source which is the field clicintie[i].IE whose function are the follows:</p>
<ul>
<li>The clicintie[i] register of each interrupt source is a both readable and writeable memory-mapped register. Hence the software can program it.</li>
<li>If the clicintie[i] register is programmed to 0, it means that this interrupt source is masked.</li>
<li>If the clicintie[i] register is programmed to 1, it means that this interrupt is enabled.</li>
</ul>
<h3 id="627-eclica-interrupt-pending-bit&#xFF08;ip&#xFF09;"><strong>6.2.7. ECLICA Interrupt Pending Bit&#xFF08;IP&#xFF09;</strong><div id="6-2-7"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As shown in Figure 62 , the ECLIC unit has allocated an interrupt pending bit (IP) for each interrupt source which is the field clicintip[i].IP whose function are the follows:</p>
<ul>
<li>If the IP bit of one interrupt source is 1, it means this interrupt is initiated. The trigger condition of the interrupt source depends on whether this interrupt is level-triggered or edge-triggered as described in Section 6.2.8.</li>
<li>The IP bit of the interrupt source is both readable and writeable. The behavior of the software writing IP bits depends on whether the interrupt source is level or edge triggered. Please see Section 6.2.8 for more details.</li>
<li>For edge-triggered interrupt source, the IP bit may be cleared by the hardware itself. Please see Section 6.2.8 for more details.</li>
</ul>
<h3 id="628-eclic-interrupt-source-level-or-edge-triggered&#xFF09;"><strong>6.2.8. ECLIC Interrupt Source Level or Edge-Triggered&#xFF09;</strong><div id="6-2-8"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As shown in Figure 62, each ECLIC interrupt source can be configured as level triggered or edge triggered by setting the value of clicintattr[i].trig. The key points are the followings: </p>
<ul>
<li>When clicintattr[i].trig[0] == 0, this interrupt source is configured as a level-triggered interrupt.<ul>
<li>If the interrupt source is configured as level-triggered, the IP bit of the interrupt source will reflect the level of the interrupt source in real time.</li>
<li>If the interrupt source is configured as level-triggered, the IP bit reflects the level of the interrupt in real time, so software writes to this IP bit is ignored, that is, the software cannot set or clear the IP bit by the write operation. If the software needs to clear the interrupt pending bit, it can only be done by clearing the original source of the interrupt.</li>
<li>When clicintattr[i].trig[0] == 1 and clicintattr[i].trig[1] == 0, this interrupt source is configured as a rising edge-triggered interrupt:</li>
<li>If the interrupt source is configured as rising edge-triggered, when the ECLIC detects the rising edge of the interrupt source, the interrupt source is triggered in the ECLIC, and the IP bit of the interrupt source is set.</li>
<li>If the interrupt source is configured as rising edge-triggered, the IP bit is writeable for the software, which means the software can set or clear the IP bit by write operations.</li>
</ul>
</li>
<li>when clicintattr[i].trig[0] == 1 and clicintattr[i].trig[1] == 1:<ul>
<li>Note: for rising edge-triggered interrupt, in order to improve the efficiency of the interrupt processing, when the interrupt is taken and the core jumps to the interrupt service routine, the hardware of the ECLIC will clear the IP bit automatically, and the software needs not to clear the IP bit in ISR.</li>
<li>When clicintattr[i].trig[0] == 1 and clicintattr[i].trig[1] == 1, this interrupt source is configured as a falling edge-triggered interrupt:</li>
<li>If the interrupt source is configured as falling edge-triggered, when the ECLIC detects the falling edge of the interrupt source, the interrupt source is triggered in the ECLIC, and the IP bit of the interrupt source is set.
If the interrupt source is configured as falling edge-triggered, the IP bit is writeable for the software, which means the software can set or clear the IP bit by write operations</li>
<li>Note: for rising edge-triggered interrupt, in order to improve the efficiency of the interrupt processing, when the interrupt is taken and the core jumps to the interrupt service routine, the hardware of the ECLIC will clear the IP bit automatically, and the software needs not to clear the IP bit in ISR.</li>
</ul>
</li>
</ul>
<h3 id="629-eclic-interrupt-level-and-priority"><strong>6.2.9. ECLIC Interrupt Level and Priority</strong><div id="6-2-9"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As shown in Figure 6-2, each interrupt sources of the ECLIC can be configured with specified level and priority, and the key points are the followings: </p>
<ul>
<li>The register clicintctl[i] of each interrupt source is 8-bit width theoretically, and effective bits actually implemented by the hardware are specified by the CLICINTCTLBITS in the register clicinfo. For example, if the value of the clicinfo.CLICINTCTLBITS field is 6, it means that only the upper 6-bit of the clicintctl[i] register are true valid bits, and the lowest 2 bits are tied to 1, as shown in Figure 6-3.<ul>
<li>Note: the field CLICINTCTLBITS is a readable constant value, and the software cannot overwrite it. The theoretically reasonable value range of it is 2 &lt;= CLICINTCTLBITS &lt;= 8. The actual value is determined by the specified hardware implementation.</li>
</ul>
</li>
<li>The effective bits of clicintctl[i] register has two dynamic fields, which are used to specify the level and the priority of the interrupt source. The width of the level filed is defined by field nlbits in cliccfg. For example, if the value of cliccfg.nlbits is 4, it means that the upper 4-bit of the effective bits in clicintctl[i] is the level field while the other lower effective bits form the priority field, as shown in the example in Figure 6-3.<ul>
<li>Note: the field cliccfg.nlbits is both readable and writeable, which means the software can program it.&#x3002;</li>
</ul>
</li>
</ul>
<p><img src="chapter6/6.assets/24.png" alt=""></p>
<p>&#x200B;                                                 <strong><center>Figure 6-3clicintctl[i]  format example</center></strong></p>
<ul>
<li>The key points of interrupt level are the followings:<ul>
<li>The value of level is read in a left-aligned manner. Except the effective bits (defined by the value of cliccfg.nlbits), the low ineffective bits are all filled with the constant 1, as shown in the example in Figure 6-4.<ul>
<li>Note&#xFF1A;if cliccfg.nlbits &gt; clicinfo.CLICINTCTLBITS&#xFF0C;it means that the number of bits indicated by nlbits exceeds the effective bits of the clicintctl[i] register, and the excess bits are all filled with the constant 1.</li>
<li>Note&#xFF1A;if cliccfg.nlbits = 0&#xFF0C;the value of level will be regarded as a fixed value 255. As shown in Figure 6-5.</li>
</ul>
</li>
<li>The greater value of level, the higher priority, note <ul>
<li>Higher-level interrupts can preempt lower-level interrupts resulting in an interrupt preemption, as detailed in Section 5.11.</li>
<li>If there are multiple pending interrupts (IP is 1), then the ECLIC needs to make an arbitration to determine which interrupt needs to be sent to the core to take. The arbitration needs to take the level of each interrupt source into the consideration. Please see Section 5.5 for details.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="chapter6/6.assets/25.png" alt=""></p>
<p>&#x200B;                                          <strong><center>Figure 6-4 Example for the decode of level</center></strong></p>
<p><img src="chapter6/6.assets/26.png" alt=""></p>
<p>&#x200B;                                           <strong><center>Figure 6-5 Examples of cliccfg settings </center></strong></p>
<ul>
<li>The key points of the interrupt priority are the follows:<ul>
<li>The value of priority is also read in a left-aligned manner. Except the effective bits (clicinfo.CLICINTCTLBITS - cliccfg.nlbits), the low ineffective bits are all filled with the constant 1.</li>
<li>The greater the value of the priority, the higher priority, note:<ul>
<li>The priority of the interrupt does not participate in the judgment of the interrupt preemption, which means whether the interrupt can be preempted or not has nothing to do with the value of the priority of the interrupt.</li>
<li>When multiple interrupts are simultaneously pending, the ECLIC needs to make an arbitration to determine which interrupt is sent to the core to handle. The arbitration needs to refer to the value of priority of each interrupt source. Please see Section 6.2.12 for details.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6210-eclici-interrupt-vectored-and-non-vectored-processing-mode"><strong>6.2.10. ECLICI Interrupt Vectored and Non-Vectored Processing Mode</strong><div id="6-2-10"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Each interrupt source of the ECLIC can be set to vectored or non-vectored (via the shv field of the register clicintattr[i]). The key points are the followings:&#xFF1A;</p>
<ul>
<li>IIf the interrupt is configured as vectored, the core will directly jump to the target address stored in the vector table entry when the interrupt is taken. For a detailed description of the interrupt vectored processing mode, please see Section 5.13.</li>
<li>If the interrupt is configured as non-vectored, the core will jump to the common base entry shared by all interrupts when the interrupt is taken. For a detailed description of the interrupt non-vectored processing mode, please see Section 5.13.</li>
</ul>
<h3 id="6211-eclic-interrupt-threshold-level"><strong>6.2.11. ECLIC Interrupt Threshold Level</strong><div id="6-2-11"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As shown in Figure 6-1, the ECLIC can set the threshold level (mth) of a specific interrupt threshold level. The key points are as follows:&#xFF1A;</p>
<ul>
<li>The mth register is an 8-bit register, all bits are readable and writable, and the software can write this register to configure the threshold. Note: this threshold indicates a level value.</li>
<li>Only when the level of the interrupt finally arbitrated by the ECLIC is higher than the value in the mth register, the interrupt can be sent to the processor core.&#x3002;</li>
</ul>
<h3 id="6212eclic-interrupt-arbitration-mechanism"><strong>6.2.12.ECLIC Interrupt Arbitration Mechanism</strong><div id="6-2-12"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As shown in Figure 6-2, the principles for the ECLIC to arbitrate all of its interrupt sources are as follows:</p>
<ul>
<li>Only interrupt sources that meet all of the following conditions can participate in the arbitration&#xFF1A;<ul>
<li>The enable bit (clicintie[i]) of the interrupt source must be 1.</li>
<li>The pending bit (clicintip[i]) of the interrupt source must be 1.</li>
</ul>
</li>
<li>The pending bit (clicintip[i]) of the interrupt source must be 1.<ul>
<li>First, determine the level, the larger the level value of the interrupt source, the higher the arbitration priority.&#x3002;</li>
<li>If the level is equal, then the interrupt source that has greater value of priority will have higher priority in the arbitration.</li>
<li>If both level and priority are equal, then the ID is taken into the consideration. The interrupt source with the larger interrupt ID has higher arbitration priority.</li>
</ul>
</li>
<li>If the level value of the interrupt source that wins the arbitration has a greater value of level than the value in mth, then the interrupt request is initiate and the corresponding interrupt request signal to the core will be asserted.</li>
</ul>
<h3 id="6213eclic-interrupt-taken-preemption-and-tail-chaining"><strong>6.2.13.ECLIC Interrupt Taken, Preemption and Tail-Chaining</strong><div id="6-2-13"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;After the ECLIC interrupt request is sent to the processor core, the core will respond to it. Through the coordination by the ECLIC and the core, the operation of interrupt preemption and tail-chaining are supported. Please see Section 5.6, Section 5.11, and Section 5.12 for more details.&#x3002;</p>
<h1 id="7-bumblebee-core-csrs-descriptions"><strong>7. Bumblebee Core CSRs Descriptions</strong><div id="7"></div></h1>
<h2 id="71-bumblebee-core-csrs-overview"><strong>7.1. Bumblebee Core CSRs Overview</strong><div id="7-1"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;In the RISC-V ISA, there are some CRSs (control and status registers) which control and record the status of processor. CSRs are the registers inside the core. And the standard RISC-V ISA sets aside a 12-bit encoding space for CSRs.</p>
<h2 id="72-bumblebee-core-csrs-list"><strong>7.2. Bumblebee Core CSRs List</strong><div id="7-2"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Table 7-1 describes the CSRs in the Bumblebee Core. In this CSRs List, there are RISC-V standard CSRs (RV32IMAC ISA support Machine Mode and User Mode) and customized CSRs in the Bumblebee Core.</p>
<p>&#x200B;                                            <strong><center>Table 7-1 CSR supported in the Bumblebee Core</center></strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Address</th>
<th>R&amp;W</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>RISC-V Standard CSR&#xFF08;Machine Mode&#xFF09;</td>
<td>0xF11</td>
<td>MRO</td>
<td>mvendorid</td>
<td>Machine Vendor ID Register</td>
</tr>
<tr>
<td></td>
<td>0xF12</td>
<td>MRO</td>
<td>marchid</td>
<td>Machine Architecture ID Register</td>
</tr>
<tr>
<td></td>
<td>0xF13</td>
<td>MRO</td>
<td>mimpid</td>
<td>Machine Implementation ID Register</td>
</tr>
<tr>
<td></td>
<td>0xF14</td>
<td>MRO</td>
<td>mhartid</td>
<td>Hart ID Register</td>
</tr>
<tr>
<td></td>
<td>0x300</td>
<td>MRW</td>
<td>mstatus</td>
<td>Machine Status Register</td>
</tr>
<tr>
<td></td>
<td>0x301</td>
<td>MRO</td>
<td>misa</td>
<td>Machine ISA Register</td>
</tr>
<tr>
<td></td>
<td>0x304</td>
<td>MRW</td>
<td>mie</td>
<td>Machine Interrupt Enable Register</td>
</tr>
<tr>
<td></td>
<td>0x305</td>
<td>MRW</td>
<td>mtvec</td>
<td>Machine Trap-Vector Base-Address Register</td>
</tr>
<tr>
<td></td>
<td>0x307</td>
<td>MRW</td>
<td>mtvt</td>
<td>ECLIC Interrupt Vector Table Base Address</td>
</tr>
<tr>
<td></td>
<td>0x340</td>
<td>MRW</td>
<td>mscratch</td>
<td>Machine Scratch Register</td>
</tr>
<tr>
<td></td>
<td>0x341</td>
<td>MRW</td>
<td>mepc</td>
<td>Machine Exception Program Counter</td>
</tr>
<tr>
<td></td>
<td>0x342</td>
<td>MRW</td>
<td>mcause</td>
<td>Machine Cause Register</td>
</tr>
<tr>
<td></td>
<td>0x343</td>
<td>MRW</td>
<td>mtval</td>
<td>Machine Trap Value Register</td>
</tr>
<tr>
<td></td>
<td>0x344</td>
<td>MRW</td>
<td>mip</td>
<td>Machine Interrupt Pending Register</td>
</tr>
<tr>
<td></td>
<td>0x345</td>
<td>MRW</td>
<td>mnxti</td>
<td>The next interrupt handler address and enable modifier</td>
</tr>
<tr>
<td></td>
<td>0x346</td>
<td>MRO</td>
<td>mintstatus</td>
<td>Current Interrupt Levels</td>
</tr>
<tr>
<td></td>
<td>0x348</td>
<td>MRW</td>
<td>mscratchcsw</td>
<td>Scratch swap register for privileged mode</td>
</tr>
<tr>
<td></td>
<td>0x349</td>
<td>MRW</td>
<td>mscratchcswl</td>
<td>Scratch swap register for interrupt levels.</td>
</tr>
<tr>
<td></td>
<td>0xB00</td>
<td>MRW</td>
<td>mcycle</td>
<td>Lower 32 bits of Cycle counter</td>
</tr>
<tr>
<td></td>
<td>0xB80</td>
<td>MRW</td>
<td>mcycleh</td>
<td>Upper 32 bits of Cycle counter</td>
</tr>
<tr>
<td></td>
<td>0xB02</td>
<td>MRW</td>
<td>minstret</td>
<td>Lower 32 bits of Instructions-retired counter</td>
</tr>
<tr>
<td></td>
<td>0xB82</td>
<td>MRW</td>
<td>minstrech</td>
</tr>
<tr>
<td>Bumblebee Customized CSR</td>
<td>0x320</td>
<td>MRW</td>
<td>mcountinhibit</td>
<td>Customized register for counters on &amp; off</td>
</tr>
<tr>
<td></td>
<td>0x7c3</td>
<td>MRO</td>
<td>mnvec</td>
<td>NMI Entry Address</td>
</tr>
<tr>
<td></td>
<td>0x7c4</td>
<td>MRW</td>
<td>msubm</td>
<td>Customized Register Storing Type of Trap</td>
</tr>
<tr>
<td></td>
<td>0x7d0</td>
<td>MRW</td>
<td>mmisc_ctl</td>
<td>Customized Register holding NMI Handler Entry Address</td>
</tr>
<tr>
<td></td>
<td>0x7d6</td>
<td>MRW</td>
<td>msavestatus</td>
<td>Customized Register holding the value of mstatus</td>
</tr>
<tr>
<td></td>
<td>0x7d7</td>
<td>MRW</td>
<td>msaveepc1</td>
<td>Customized Register holding the value of mepc for the first-level preempted NMI or Exception.</td>
</tr>
<tr>
<td></td>
<td>0x7d8</td>
<td>MRW</td>
<td>msavecause1</td>
<td>Customized Register holding the value of mcause for the first-level preempted NMI or Exception.</td>
</tr>
<tr>
<td></td>
<td>0x7d9</td>
<td>MRW</td>
<td>msaveepc2</td>
<td>Customized Register holding the value of mepc for the second-level preempted NMI or Exception.</td>
</tr>
<tr>
<td></td>
<td>0x7da</td>
<td>MRW</td>
<td>msavecause2</td>
<td>Customized Register holding the value of mcause for the second-level preempted NMI or Exception.</td>
</tr>
<tr>
<td></td>
<td>0x7eb</td>
<td>MRW</td>
<td>pushmsubm</td>
<td>Push msubm to sack</td>
</tr>
<tr>
<td></td>
<td>0x7ec</td>
<td>MRW</td>
<td>mtvt2</td>
<td>Customizzed Register holding the value of mepc for first-level preemoted NI or Exception</td>
</tr>
<tr>
<td></td>
<td>0x7ed</td>
<td>MRW</td>
<td>jalmnxti</td>
<td>ECLIC non-vectored interrupt handler address register</td>
</tr>
<tr>
<td></td>
<td>0x7ee</td>
<td>MRW</td>
<td>pushmcause</td>
<td>put mcause to stack</td>
</tr>
<tr>
<td></td>
<td>0x7ef</td>
<td>MRW</td>
<td>pushmepc</td>
<td>Push mepc to stack</td>
</tr>
<tr>
<td></td>
<td>0x811</td>
<td>MRW</td>
<td>sleepvalue</td>
<td>WFI Sleep Mode Register</td>
</tr>
<tr>
<td></td>
<td>0x812</td>
<td>MRW</td>
<td>txevt</td>
<td>Send Event Register</td>
</tr>
<tr>
<td></td>
<td>0x810</td>
<td>MRW</td>
<td>wfe</td>
<td>Wait for Event Register</td>
</tr>
</tbody>
</table>
<p>Note&#xFF1A;</p>
<ul>
<li>MRW--Machine Mode Readable/Writeable </li>
<li>MRO--Machine Mode Read-Only</li>
<li>URW--User Mode Readable/Writeable</li>
<li>URO--User Mode Read-Only</li>
</ul>
<h2 id="73-accessibility-of-csr-in-the-bumblebee-core-"><strong>7.3. Accessibility of CSR in the Bumblebee Core </strong><div id="7-3"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The CSRs read and write rule in the Bumblebee core:</p>
<ul>
<li>No matter in Machine Mode or User Mode:<ul>
<li>If CSR register address not exist, there will be an Illegal Instruction Exception.</li>
</ul>
</li>
<li>In Machine Mode:<ul>
<li>For MRW or URW CSRs, read and write operations go well.</li>
<li>For MRO or URO CSRs, read operation goes well.</li>
<li>If trying to write data in MRO and URO CSRs, there will be an Illegal Instruction Exception.</li>
</ul>
</li>
<li>In User Mode:<ul>
<li>For URW CSRs, read and write operations go well.</li>
<li>For URO CSRs, read operation goes well.<ul>
<li>Note&#xFF1A;For URO registers like cycle&#x3001;cycleh&#x3001;time&#x3001;timeh&#x3001;instret&#x3001;instreth,  read permissions are decided by relevant field in mcounteren, See Section 7.4.29 for more information. </li>
</ul>
</li>
<li>If trying to write data in URO CSRs, there will be an Illegal Instruction Exception. </li>
<li>If trying to write data in MRO and MRW CSRs, there will be an Illegal Instruction Exception.</li>
</ul>
</li>
</ul>
<h2 id="74--bumblebee-core-risc-v-standard-csr"><strong>7.4.  Bumblebee Core RISC-V Standard CSR</strong><div id="7-4"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;This chapter introduces the RISC-V Standard CSRs in the Bumblebee Core (RV32IMAC, support Machine Mode and User Mode).</p>
<h3 id="741-misa"><strong>7.4.1. misa</strong><div id="7-4-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;misa CSR is used to report the ISA supported by the hart.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The highest 2 bits represent current register width of the machine:</p>
<ul>
<li>If the value of highest two bits is 1, current architecture is RV32. </li>
<li>If the value of highest two bits is 2, current architecture is RV64.</li>
<li>If the value of highest two bits is 3, current architecture is RV128.</li>
</ul>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The [25:0] bits of misa CSR encodes the presence of the standard extension, with a single bit per letter of the alphabet (bit 0 encodes presence of extension A&quot; , bit 1 encodes presence of extension B&quot;, through to bit 25 which encodes Z&quot;). Figure 7-1 show the description of each alphabet . The bits that not used in this register are reserved 0.</p>
<p><img src="chapter7/7.4/7.4.1.assets/27.png" alt=""></p>
<p>&#x200B;                                       <strong><center>Figure 7-1  Encoding of [25:0] field in misa </center></strong></p>
<p>Note: misa CSR is defined as a readable and writable register on RISC-V SPEC, which allows some kinds of processor change the value of misa dynamically. However, in the Bumblebee design, misa is a readable only register which shows what extension supported in the processor.</p>
<h3 id="742-mie"><strong>7.4.2. mie</strong><div id="7-4-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mie CSR is not used under the ECLIC interrupt mode, the read value of mie is always 0.</p>
<h3 id="743-mvendorid"><strong>7.4.3. mvendorid</strong><div id="7-4-3"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;This CSR is a read-only register providing the Vendor ID of the provider of the core. If the value of this register is 0, it means the register is not implemented.</p>
<h3 id="744-marchid"><strong>7.4.4. marchid</strong><div id="7-4-4"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;This CSR is a read-only register encoding the microarchitecture ID of the processor.If the value of this register is 0, it means the register is not implemented.</p>
<h3 id="745-mimpid"><strong>7.4.5. mimpid</strong><div id="7-4-5"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;This CSR is a read-only register provide a unique encoding of the version of the processor implementation which named as implementation ID.</p>
<h3 id="746-mhartid"><strong>7.4.6. mhartid</strong><div id="7-4-6"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;This CSR is a read-only register containing the integer ID of the hardware thread running the code.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Hart means hardware thread. In each single core, there may exist multiple threads such as Hyper-threading technique. Each thread has it own register files but shares most of the data processing resources. In this kind of Hyper-threading processor, a core will have multiple hart.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;In the Bumblebee, hart ID is controlled by signal core_mhartid. Note: According to RISC-V architecture, we must ensure exactly one hart runs some code and so require one hart to have a known hart ID of 0.</p>
<h3 id="747-mstatus"><strong>7.4.7. mstatus</strong><div id="7-4-7"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;mstatus register in under Machine Mode status register . For more details about mstatus are in Table 7-2 mstatus register.</p>
<p>&#x200B;                                                       <strong><center>Table 7-2 mstatus register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>bit</strong></th>
<th><strong>Reset</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Reserved</strong></td>
<td>2:0</td>
<td>N/A</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>MIE</strong></td>
<td>3</td>
<td>0</td>
<td>see chapter 7.4.9 for more detail.</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>6:4</td>
<td>N/A</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>MPIE</strong></td>
<td>7</td>
<td>0</td>
<td>See chapter 7.4.9 for more detail.</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>10:8</td>
<td>N/A</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>MPP</strong></td>
<td>12:11</td>
<td>0</td>
<td>See chapter 7.4.9 for more details.</td>
</tr>
<tr>
<td><strong>FS</strong></td>
<td>14:13</td>
<td>0</td>
<td>See chapter 7.4.10 for more details.</td>
</tr>
<tr>
<td><strong>XS</strong></td>
<td>16:15</td>
<td>0</td>
<td>See chapter 7.4.11 for more details.</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>17</td>
<td>N/A</td>
<td>Not used bit</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>30:18</td>
<td>N/A</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>SD</strong></td>
<td>31</td>
<td>0</td>
<td>See chapter 7.4.12 for more detail.</td>
</tr>
</tbody>
</table>
<h3 id="748-the-mie-field-in-mstatus"><strong>7.4.8. The Mie field in mstatus</strong><div id="7-4-8"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mie filed in mstatus control interrupt enable function.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When mie equals 1, interrupts are enabled. </p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When mie equals 0, interrupts are disabled.</p>
<p>Note: In the Bumblebee core, when the processor start to work in exception, interrupt or nmi mode, mie filed will update to 0 which means interrupts are blocked in exception, interrupt or nmi mode.</p>
<h3 id="749-the-mpie-and-mpp-in-mstatus"><strong>7.4.9. The MPIE and MPP in mstatus</strong><div id="7-4-9"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The MPIE and MPP fields in mstatus help to save mstatus.MIE value before core entering exception, interrupt and NMI mode, and recover it automatically in privilege mode.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When the Bumblebee core has exception, MPIE and MPP fields will be updated. See chapter 3.4.5 for more detail.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When the Bumblebee core quits exception mode (mret instruction in handler), MPIE and MPP fields will be updated. See chapter 3.5.2 for more detail.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When the Bumblebee core has NMI, MPIE and MPP fileds will be updated. See chapter 4.3.4 for more detail.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When the Bumblebee core quits NMI mode (mret instruction in handler), MPIE and MPP fields will be updated. See chapter 4.4.2 for more detail.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When the Bumblebee core has interrupts, MPIE and MPP fields will be updated. See chapter 5.6.5 for more detail.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When the Bumblebee core quits interrupts mode (mret instruction in handler), MPIE and MPP fields will be updated. See chapter 5.7.2 for more detail.</p>
<p>Note: The mstatus.MPIE and mstatus.MPP are the mirror images of mcause.MPIE and mcause.MPP. Normally, the value of mstatus.MPIE and mstatus.MPP are the same as the value of mcause.MPIE and mcause.MPP.</p>
<h3 id="7410-the-xs-field-in-mstatus"><strong>7.4.10. The XS field in mstatus</strong><div id="7-4-10"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The FS field in mstatus encodes the status of the floating-point unit.</p>
<p>The FS field contains 2 bits, the encoding of FS field is listed as the following figure:</p>
<p><img src="chapter7/7.4/7.4.10.assets/28.png" alt=""></p>
<p>&#x200B;                                                               <strong><center>Figure 7-2 FS Field Status Encode</center></strong></p>
<p>The rule of updating FS field:</p>
<ul>
<li>When the core turned on, the default value is 0, which means the FPU status is off. In order to use FPU, software need a CSR write instruction to change the value of FS into a non-zero value that turn on FPU.</li>
<li>If the FS field is 1 or 2, after a FP instruction executed, FS field will be changed to 3 which indicates the status of FPU is dirty(changed). </li>
<li>If the processor don&#x2019;t want to use FPU (e.g. turn off FPU for low power consumption), a CSR write instruction can set the mstatus.FS to 0 which will turn off FPU. After FPU is off, any operations access to floating-point CSR and floating-point instructions will generate an illegal instruction exception.</li>
</ul>
<p>Besides, FS field can be checked by a context switch routine to quickly determine whether a state save or restore is required. See The RISC-V Instruction Set Manual v1.10 for more information if interested.</p>
<h3 id="7411-the-xs-field-in-mstatus"><strong>7.4.11. The XS field in mstatus</strong><div id="7-4-11"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The XS field is similar to FS field and encodes the status of additional user-mode extensions and associated state</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;According to standard RISC-V &#x201C;Privileged Architecture Document Version 1.10&#x201D;, XS field is a read-only field. Note please, in the Bumblebee core, XS field is a read and write field. The function of XS is like that of FS. Software is able to change the value of XS to turn on or off the additional user-mode extensions unit.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Like FS field, XS field can be checked by a context switch routine to quickly determine whether a state save or restore is required. See The RISC-V Instruction Set Manual v1.10 for more information if interested.</p>
<h3 id="7412-the-sd-field-in-mstatus"><strong>7.4.12. The SD field in mstatus</strong><div id="7-4-12"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The SD bit is a read-only bit that summarizes whether either the FS field or XS field signals the presence of some dirty state that will require saving extended user context to memory. The logic expression between FS, XS and SD is: SD = ((FS == 11)) or (DS == 11).</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The SD bit is read-only and is set to quickly find either the FS or XS bits encode a Dirty state. And SD field can be checked by a context switch routine to quickly determine whether a state save or restore is required in FPU or additional extensions unit</p>
<h3 id="7413-mtvec"><strong>7.4.13. mtvec</strong><div id="7-4-13"></div></h3>
<p>The mtvec register holds trap vector configuration, consisting of a vector base address (BASE) and a vector mode (MODE).</p>
<ul>
<li>When mtvec holds the exception entry address:<ul>
<li>The value of the address field must always be aligned on a 4-byte boundary</li>
</ul>
</li>
<li>When mtvec holds the interrupt entry address:<ul>
<li>When mtvec.MODE != 6&#x2019;b000011, processor uses default interrupt mode.</li>
<li>When mtvec.MODE = 6&#x2019;b000011, processor uses ECLIC interrupt mode (recommend).<ul>
<li>See chapter 5.13.2 for more information about interrupt non-vectored mode entry address.  </li>
<li>See chapter 5.13.1 for more information about interrupt vectored mode entry address. </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Field of mtvec register is shown in Table 7-3.</p>
<p>&#x200B;                                                  <strong><center>Table 7-3 mtvec register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ADDR</strong></td>
<td>31:6</td>
<td>mtvec address</td>
</tr>
<tr>
<td><strong>MODE</strong></td>
<td>5:0</td>
<td>MODE field determine interrupt mode&#xFF1A;000011: ECLIC interrupt mode(recommend) Others: Default interrupt mode</td>
</tr>
</tbody>
</table>
<h3 id="7414-mtvt"><strong>7.4.14. mtvt</strong><div id="7-4-14"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mtvt register holds the base address of ECLIC vector interrupts, and the base address is aligned at least 64-byte boundary.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;In order to improve the performance and reduce the gate count, the alignment of the base address in mtvt is determined by the actual number of interrupts, which is shown in the following table.</p>
<p>&#x200B;                                                                 <strong><center>Table 7-4 mtvt alignment</center></strong></p>
<table>
<thead>
<tr>
<th>Max interrupt number</th>
<th>mtvt alignment</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 to 16</td>
<td>64-byte</td>
</tr>
<tr>
<td>17 to 32</td>
<td>128-byte</td>
</tr>
<tr>
<td>33 to 64</td>
<td>256-byte</td>
</tr>
<tr>
<td>65 to 128</td>
<td>512-byte</td>
</tr>
<tr>
<td>129 to 256</td>
<td>1KB</td>
</tr>
<tr>
<td>257 to 512</td>
<td>2KB</td>
</tr>
<tr>
<td>513 to 1024</td>
<td>4KB</td>
</tr>
<tr>
<td>1025 to 2048</td>
<td>8KB</td>
</tr>
<tr>
<td>2045 to 4096</td>
<td>16KB</td>
</tr>
</tbody>
</table>
<h3 id="7415-mscratch"><strong>7.4.15. mscratch</strong><div id="7-4-15"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mscratch register is used by programs in Machine Mode to temporarily save some specified data. The mscratch register provides a save and restore mechanism. For example, after entering the interrupt or exception handling mode, the application&apos;s stack pointer (SP) register is temporarily stored in the mscratch register. Before exiting the exception handler, the value in mscratch is used to restore the Stack Pointer (SP) register.</p>
<h3 id="7416-mepc"><strong>7.4.16. mepc</strong><div id="7-4-16"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mepc register is written with the virtual address of the instruction that encountered the exception, and the processor will return to this address after the exception finish.</p>
<p>Note&#xFF1A;</p>
<ul>
<li>When an instruction encounters an exception, mepc register will be updated to the instruction PC address</li>
<li>Though mepc register can be updated automatically by hardware when there is an exception, mepc is a readable and writable register. So, software can also modify the value of the register directly.</li>
</ul>
<p>Field of mepc register is shown in Table 7-5.</p>
<p>&#x200B;                                                        <strong><center>Table 7-5 mepc register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>EPC</strong></td>
<td>31&#xFF1A;1</td>
<td>The PC address of the instruction that encountered the exception</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>0</td>
<td>Reserved 0</td>
</tr>
</tbody>
</table>
<h3 id="7417-mcause"><strong>7.4.17. mcause</strong><div id="7-4-17"></div></h3>
<p>The mcause is written with a code indicating the reason that caused the trap.</p>
<p>The mcause register is formatted as shown in Table 7-6.</p>
<p>&#x200B;                                                    <strong><center>Table 7-6 mcause register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>INTERRUPT</strong></td>
<td>31</td>
<td>Current Trap type&#xFF1A;                                                                                                0&#xFF1A;Exception or NMI                                                                                                      1&#xFF1A;Interrupt</td>
</tr>
<tr>
<td><strong>MINHV</strong></td>
<td>30</td>
<td>Indicate processer is reading interrupt vector table.</td>
</tr>
<tr>
<td><strong>MPP</strong></td>
<td>29:28</td>
<td>privilege mode before interrupt, the same as mstatus.mpp</td>
</tr>
<tr>
<td><strong>MPIE</strong></td>
<td>27</td>
<td>Interrupt enable before interrupt, the same</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>26:24</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>MPIL</strong></td>
<td>23:16</td>
<td>Previous interrupt level</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>15:12</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>EXCCODE</strong></td>
<td>11:0</td>
<td>Exception/Interrupt Encoding</td>
</tr>
</tbody>
</table>
<p>Note&#xFF1A;</p>
<ul>
<li>he mstatus.MPIE and mstatus.MPP are the mirror images of mcause.MPIE and mcause.MPP.</li>
<li>The mcause.EXCCODE of NMI can be 0x1 or 0xfff&#xFF0C;the value is controlled by mmisc_ctl, see more detail in Section 7.5.4.</li>
</ul>
<h3 id="7418-mtval&#xFF08;mbadaddr&#xFF09;"><strong>7.4.18. mtval&#xFF08;mbadaddr&#xFF09;</strong><div id="7-4-18"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mtval register (mbadaddr in the previous specification) is written with the faulting effective address or faulting instruction code to assist software in handling the trap.</p>
<p>The mtval register (mbadaddr in the previous specification) is written with the faulting effective address or faulting instruction code to assist software in handling the trap.</p>
<p>When the Bumblebee core takes an exception, mtval is written with exception-specific information.</p>
<h3 id="7419-mip"><strong>7.4.19 mip</strong><div id="7-4-19"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mip register has NO effect when interrupt handling mode is ECLIC, and return data are all zeros while reading the register.</p>
<h3 id="7420-mnxti"><strong>7.4.20. mnxti</strong><div id="7-4-20"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mnxti register&#xFF08;Next Interrupt Handler Address and Interrupt-Enable CSR&#xFF09;can be used by software to service the next interrupt when it is in the same privilege mode, without incurring the full cost of an interrupt pipeline flush and context save/restore.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mnxti CSR is designed to be accessed using CSRRSI/CSRRCI instructions, where the value read is the next interrupt handler address and the write back updates the interrupt-enable status.</p>
<p>Note:</p>
<ol>
<li>If the next interrupt is not executed in the same privilege mode, the processor will take the next interrupt directly in a nested way, and mnxti only work when the next interrupt is in the same privilege mode.</li>
<li>The mnxri CSR instruction is not the same as normal CSR instructions, the return value is different.</li>
<li>The return value of mnxti CSR read instruction is shown below:<ul>
<li>For the following situations, return 0.<ul>
<li>No valid interrupt.</li>
<li>The highest priority interrupt is vectored.</li>
</ul>
</li>
<li>When the interrupt non-vectored, return the interrupt entry address</li>
</ul>
</li>
<li>The mnxti CSR write operation will update following register:<ul>
<li>The mstatus register is the RMW&#xFF08;read-modify-write&#xFF09;operation target register.</li>
<li>The mcause.EXCCODE field will be updated to the value of the corresponding ID of the taken interrupt</li>
<li>The mintstatus.MIL will be updated to current interrupt level.</li>
</ul>
</li>
</ol>
<h3 id="7421-mintstatus"><strong>7.4.21. mintstatus</strong><div id="7-4-21"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mintstatus register holds the active interrupt level for all the privilege mode.</p>
<p>&#x200B;                                                      <strong><center>Table 7-7 minstatus register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>MIL</strong></td>
<td>31:24</td>
<td>The active interrupt level in machine mode</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>23&#xFF1A;8</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>UIL</strong></td>
<td>7:0</td>
<td>The active interrupt level in user mode</td>
</tr>
</tbody>
</table>
<h3 id="7422-mscratchcsw"><strong>7.4.22. mscratchcsw</strong><div id="7-4-22"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mscratchcsw register is useful to swap the value between target register and mscratch when privilege mode change.</p>
<p>Using CSR read instruction to operate mscratchcsw, when the privilege mode change after an interrupt, there will be pseudo instruction operation shown below:</p>
<pre><code> csrrw rd&#xFF0C; mscratchcsw&#xFF0C; rs1

  // Pseudocode operation.
  if &#xFF08;mcause.mpp!=M-mode&#xFF09; then {
      t = rs1; rd = mscratch; mscratch = t;
  } else {
      rd = rs1; // mscratch unchanged.
  }

  // Usual use: csrrw sp&#xFF0C; mscratchcsw&#xFF0C; sp
</code></pre><p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;When processor takes an interrupt in low privilege mode, processor enters high privilege mode to handle the interrupt and need stacks to store the status of processor before the interrupt. If the processor continues to use SP in low privilege mode, the data in high privilege mode will be stored in the area which can be accessed in low privilege mode and cause safety error. RISC-V define that when the processor is in low privilege mode, data in SP of high privilege mode should be stored in mscratch. And in this way, SP will be recovered from mscratch when the processor enters high privilege mode.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;It will cost a lot of cycles to running the program above, so RISC-V define mscratchcsw register. After entering an interrupt, processor run a mscratchcsw CSR instruction to swap the value between mscratch and SP to make SP in high privilege mode recovered. At the same time, copy data in low privilege mode SP to mscratch. Before mret instruction, add a mscratchcsw instruction to swap value between mscratch and SP. It will make low privilege mode SP recovered and store high privilege mode SP to mscratch again. It is really convenient to use these 2 instructions to solve the SP problem and speed up the interrupt handling.</p>
<p>Note: to avoid virtualization vulnerabilities, the software cannot directly read the core&#x2019;s current privilege mode. If the software attempts to access the mscratchcsw register to perform a swap operation, the processor will take a trap, so the register mscratchcsw does not cause a virtualization vulnerability.</p>
<h3 id="7423-mscratchcswl"><strong>7.4.23. mscratchcswl</strong><div id="7-4-23"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mscratchcswl register is used to exchange the destination register with the value of mscratch to speed up interrupt processing when switching between multiple interrupt levels.</p>
<p>Using the CSR instruction to read the register mscratchcsw, with unchanged privilege mode, the following register operations are performed when there is a switch between the interrupt handler and the application program:</p>
<pre><code>csrrw rd&#xFF0C; mscratchcswl&#xFF0C; rs1


  // Pseudocode operation.

  if &#xFF08; &#xFF08;mcause.mpil==0&#xFF09; != &#xFF08;mintstatus.mil == 0&#xFF09; &#xFF09; then {

&#x200B;      t = rs1; rd = mscratch; mscratch = t;

  } else {

&#x200B;      rd = rs1; // mscratch unchanged.

  }


  // Usual use: csrrw sp&#xFF0C; mscratchcswl&#xFF0C; sp
</code></pre><p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;In single privilege mode, separating the interrupt handler task from the task space of the application task can increase robustness, reduce space usage, and facilitate system debugging. The interrupt handler has a non-zero interrupt level while the application task has a zero interrupt level. According to this feature, the RISC-V architecture defines the mscratchcswl register. Similar to mscratchcsw, adding a register instruction of mscratchcswl to the beginning and the end of the interrupt service routine enables a fast stack pointer switch between the interrupt handler and the application, ensuring the separation of the stack space between the interrupt handler and the application.</p>
<h3 id="7424-mcycle-and-mcycleh"><strong>7.4.24. mcycle and mcycleh</strong><div id="7-4-24"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The RISC-V architecture define a 64-bits width cycle counter which indicates how many cycles has the processor executed. Whenever the processor is working, the counter will increase automatically.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mcycle register records the low 32-bits of counter and mcycleh records the high 32-bits.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mcycle and mcycleh show the performance of the processor. And they are RW registers, software can change the value of them with CSR instruction.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Considering the counter has power consumption, there is an extra bit in the customized CSR mcountinhibit that can turn off the counter to save power when users don&#x2019;t need to learn the performance of the professor through the counter. See chapter 7.5.1 for more information about mcountinhibit.</p>
<p>Note:  In debug mode, counter doesn&#x2019;t work. The counter only works when the processor works normally.</p>
<h3 id="7425-minstret-and-minstreth"><strong>7.4.25. minstret and minstreth</strong><div id="7-4-25"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The RISC-V architecture define a 64-bits width counter which records how many instructions have been executed successfully. Whenever an instruction is done, the counter number will plus one.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The minstret register records the low 32-bits of counter and minstreth records the high 32-bits.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The minstret and minstreth show the performance of the processor. And they are RW registers, software can change the value of them with CSR instruction.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Considering the counter has power consumption, there is an extra bit in the customized CSR mcountinhibit that can turn off the counter to save power when users don&#x2019;t need to learn the performance of the professor through the counter. See chapter 7.5.1 for more information about mcountinhibit.</p>
<p>Note:  In debug mode, counter doesn&#x2019;t work. The counter only works when the processor works normally.</p>
<h3 id="7426-cycle-and-cycleh"><strong>7.4.26. cycle and cycleh</strong><div id="7-4-26"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The cycle and cycleh are read-only shadows of mcycle and mcycleh. In user mode, CSR mcounteren.CY field determines if cycle and cycleh are readable. See Section 7.4.29 for more information.</p>
<h3 id="7427-instret-and-instreth"><strong>7.4.27. instret and instreth</strong><div id="7-4-27"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The instret and instreth are read-only shadows of minstret and minstreth. In user mode, CSR mcounteren.IR field determines if instret and instreth are readable. See Section 7.4.29 for more information.</p>
<h3 id="7428-time-and-timeh"><strong>7.4.28. time and timeh</strong><div id="7-4-28"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The time and timeh are read-only shadows of mtime and mtimeh. In user mode, CSR mcounteren.TM field determines if time and timeh are readable. See Section 7.4.29 for more information.</p>
<h3 id="7429-mcounteren"><strong>7.4.29. mcounteren</strong><div id="7-4-29"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mcounteren register only exists when the processor support user mode. The format of mcounteren register is shown in Table 7-8.</p>
<p>&#x200B;                                                <strong><center>Table 7-8 mcounteren register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CY</strong></td>
<td>0</td>
<td>The bit control if cycle and cycleh registers are readable in user mode&#xFF1A;</td>
</tr>
</tbody>
</table>
<p> If this bit is 1, cycle and cycleh are readable in user mode&#x3002;
 If this bit is 0, reading cycle and cycleh will trigger illegal instruction exception in user mode
Reset default value is 0. |
| <strong>TM</strong>       | 1      | The bit control if time and timeh registers are readable in user mode&#xFF1A;
 If this bit is 1, time and timeh are readable in user mode&#x3002;
 If this bit is 0, reading time and timeh will trigger illegal instruction exception in user mode
Reset default value is 0. |
| <strong>IR</strong>       | 2      | bit control if instret and instreth registers are readable in user mode&#xFF1A;
 If this bit is 1, instret and instreth are readable in user mode&#x3002;
If this bit is 0, reading instret and instreth will trigger illegal instruction exception in user mode
Reset default value is 0. |
| <strong>Reserved</strong> | 3~31   | Reserved 0                                        |</p>
<h2 id="75-bumblebee-core-customized-csr"><strong>7.5. Bumblebee Core Customized CSR</strong><div id="7-5"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;This section introduces customized CSRs in the Bumblebee core</p>
<h3 id="751-mcountinhibit"><strong>7.5.1. mcountinhibit</strong><div id="7-5-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mcountinhibit register controls mcycle and minstret registers. The format of mcountinhibit is shown in Table 7-9.</p>
<p>&#x200B;                                                   <strong><center>Table 7-9 mcountihibit register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Reserved</strong></td>
<td>31:3</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>IR</strong></td>
<td>2</td>
<td>When IR is 1,minstret is off</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>1</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>CY</strong></td>
<td>0</td>
<td>When CY is 1,mcycle is off</td>
</tr>
</tbody>
</table>
<h3 id="752-mnvec"><strong>7.5.2. mnvec</strong><div id="7-5-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The mnvec register holds the NMI entry address.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;In order to understand this register, please see chapter 4 for more information about NMI.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;During a processor running a program, the program will be forced to jump into a new PC address when a NMI triggered. The PC address is determined by mnvec.</p>
<p>Note: The value of mnvec is controlled by mmisc_ctl, see more information in chapter 7.5.4.</p>
<h3 id="753-msubm"><strong>7.5.3. msubm</strong><div id="7-5-3"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core customized CSR msubm register holds the current trap type and the trap type before the current trap.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The format of msubm register is shown in Table 7-10.</p>
<p>&#x200B;                                                      <strong><center>Table 7-10 msubm register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Reserved</strong></td>
<td>31:10</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>PTYP</strong></td>
<td>9:8</td>
<td>Trap type before entering a new trap: 0&#xFF1A;No-Trap 1&#xFF1A;Interrupt   2&#xFF1A;Exception  3&#xFF1A;NMI</td>
</tr>
<tr>
<td><strong>TYP</strong></td>
<td>7:6</td>
<td>Current trap type:n 0&#xFF1A;No-trap 1&#xFF1A;Interrupt 2&#xFF1A;Exception 3&#xFF1A;NMI</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>5:0</td>
<td>Reserved 0</td>
</tr>
</tbody>
</table>
<h3 id="754-mmiscctl"><strong>7.5.4. mmisc_ctl</strong><div id="7-5-4"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core customized CSR mmisc_ctl controls the value of mnvec and the mcause value of NMI.
The format of mmisc_ctl is shown in Table 7-11.</p>
<p>&#x200B;                                                 <strong><center>Table 7-11 mmisc_ctl register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Reserved</strong></td>
<td>31:10</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>NMI_**</strong>CAUSE_FFF**</td>
<td>9</td>
<td>Control mnvec and mcause.EXCCODE of NMI:</td>
</tr>
</tbody>
</table>
<p>&#xF06E;0&#xFF1A;The value of mnvec equals the PC address after reset, mcause.EXCCODE of NMI is 0x1.
1&#xFF1A;The value of mnvec is the same as the value of mnvec , mcause.EXCCODE of NMI is 0xfff  |
| <strong>Reserved</strong>          | 8:0    | Reserved 0                                            |</p>
<h3 id="755-msavestatus"><strong>7.5.5. msavestatus</strong><div id="7-5-5"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The msavestatus holds the value of mstatus and msubm which guarantee mstatus and msubm will not be flushed by NMI or exception. The msavestatus has two-stage stack, and supports up to 3-level NMI/Exception state save. See Section 4.6 for more information</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;msavestatusThe format of msavestatus register is shown in Table 7-12.</p>
<p>&#x200B;                                          <strong><center>Table 7-12 msavestatus register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Reserved</strong></td>
<td>31:16</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>PTYP2</strong></td>
<td>15:14</td>
<td>The trap type before taking the second-level NMI/Exception</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>13:11</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>MPP2</strong></td>
<td>10:9</td>
<td>The privilege mode before taking the second-level NMI/Exception.</td>
</tr>
<tr>
<td><strong>MPIE2</strong></td>
<td>8</td>
<td>The interrupt enable bit before taking the second-level NMI/Exception.</td>
</tr>
<tr>
<td><strong>PTYP1</strong></td>
<td>7:6</td>
<td>The trap type before taking the first-level NMI/Exception.</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>5:3</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>MPP1</strong></td>
<td>2:1</td>
<td>The privilege mode before taking the second-level NMI/Exception.</td>
</tr>
<tr>
<td><strong>MPIE1</strong></td>
<td>0</td>
<td>The interrupt enable bit before taking the second-level NMI/Exception.</td>
</tr>
</tbody>
</table>
<h3 id="756-msaveepc1-and-msaveepc2"><strong>7.5.6. msaveepc1 and msaveepc2</strong><div id="7-5-6"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;msaveepc1 and msaveepc2 are registers of the first-level NMI/Exception status stack and the second-level NMI/Exception status stack, used to save the PC before the first-level NMI/Exception preemption and the second-level NMI/Exception preemption respectively.</p>
<ul>
<li>msaveepc2 &lt;= msaveepc1 &lt;= mepc &lt;= interrupted PC &lt;= NMI/exception PC</li>
</ul>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Executing the mret instruction, and the value of mcause.INTERRUPT is 0 (Such as NMI or exception), msaveepc1 and msaveepc2 are used to restore the PC through the first and second level NMI/Exception Status Stacks.</p>
<ul>
<li>msaveepc2 =&gt; msaveepc1 =&gt; mepc =&gt; PC</li>
</ul>
<h3 id="757-msavecause1-and-msavecause2"><strong>7.5.7. msavecause1 and msavecause2</strong><div id="7-5-7"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;msavecause1 and msavecause2 are registers of the first-level NMI/Exception status stack and the second-level NMI/Exception status stack, used to save the mcause before the first-level NMI/Exception preemption and the second-level NMI/Exception preemption respectively.</p>
<ul>
<li>msavecause2 &lt;= msavecause1 &lt;= mcause &lt;= NMI/exception cause</li>
</ul>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Executing the mret instruction, and the value of mcause.INTERRUPT is 0 (Such as NMI or exception), msavecause1 and msavecause2 are used to restore the PC through the first and second level NMI/Exception Status Stacks.</p>
<ul>
<li>msavecause2 =&gt; msavecause1 =&gt; mcause</li>
</ul>
<h3 id="758-pushmsubm"><strong>7.5.8. pushmsubm</strong><div id="7-5-8"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core customized CSR pushmsubm provides a method to store the value of msubm in memory space which base address is SP with CSR instruction csrrwi.</p>
<p>For example:</p>
<pre><code>csrrwi x0&#xFF0C; PUSHMSUBM&#xFF0C; 1
</code></pre><p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;This instruction stores the value of msubm in SP+1*4 address.</p>
<h3 id="759-mtvt2"><strong>7.5.9. mtvt2</strong><div id="7-5-9"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;mtvt2 is used to indicate the entry address of the common base handler shared by all ECLIC non-vectored interrupts.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The bits assignment of the register mtvt2 are shown in the table below:</p>
<p>&#x200B;                                                    <strong><center>Table 7-13 mtvt2  register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CMMON-CODE-ENTRY</strong></td>
<td>31:2</td>
<td>When mtvt2.MTVT2EN=1&#xFF0C;this field determines the entry address of interrupt common code in ECLIC non-vector mode.</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>1</td>
<td>Reserved 0</td>
</tr>
<tr>
<td><strong>MTVT2EN</strong></td>
<td>0</td>
<td>mtvt2 enable&#xFF1A;</td>
</tr>
</tbody>
</table>
<p>&#xF06E;0&#xFF1A;the entry address of interrupt common code in ECLIC non-vector mode is determined by mtvec
1:  the entry address of interrupt common code in ECLIC non-vector mode is determined by mtvt2.COMMON-CODE-ENTRY  |</p>
<h3 id="7510-jalmnxti"><strong>7.5.10. jalmnxti</strong><div id="7-5-10"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core customized CSR reduces the delay for interrupt and accelerates interrupt tail-chaining.</p>
<p>In the jalmnxti, in addition to enabling the interrupt in mnxri, handling the next interrupt and jumping to the next interrupt entry address, it can jump to the interrupt handler. So, the jalmnxti can decrease the instruction numbers to speed up the interrupt handling. See more information about jalmnxti in Section 5.13.1.3.</p>
<h3 id="7511-pushmcause"><strong>7.5.11. pushmcause</strong><div id="7-5-11"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core customized CSR pushmcause provides a method to store the value of mcause in memory space which base address is SP with CSR instruction csrrwi.</p>
<p>For example:</p>
<pre><code>csrrwi x0&#xFF0C; PUSHMCAUSE&#xFF0C; 1
</code></pre><p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;This instruction stores the value of mcause in SP+1*4 address.</p>
<h3 id="7512-pushmepc"><strong>7.5.12. pushmepc</strong><div id="7-5-12"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core customized CSR pushmepc provides a method to store the value of mepc in memory space which base address is SP with CSR instruction csrrwi.</p>
<p>For example:</p>
<pre><code>csrrwi x0&#xFF0C; PUSHMPEC&#xFF0C; 1
</code></pre><p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;This instruction stores the value of mepc in SP+1*4 address.</p>
<h3 id="7513-sleepvalue"><strong>7.5.13. sleepvalue</strong><div id="7-5-13"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core customized CSR sleepvalue controls different sleep mode. See Section 8.1 for more information. The format of sleepvalue register is shown in the table below:</p>
<p>&#x200B;                                                   <strong><center>Table 7-14 sleepvalue register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SLEEPVALUE</strong></td>
<td>0</td>
<td>Control WFI sleep mode:                                                                                                          0&#xFF1A;shallow sleep mode (After WFI, core_clk is off)       1&#xFF1A;deep sleep mode (After WFI, core_clk and core_aon_clk are off)Reset default value is 0.</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>31:1</td>
<td>Reserved 0</td>
</tr>
</tbody>
</table>
<h3 id="7514-txevt"><strong>7.5.14. txevt</strong><div id="7-5-14"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core customized CSR txevt controls output events.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The format of txevt register is shown in Table 7-15.</p>
<p>&#x200B;                                                   <strong><center>Table 7-15 txevt  register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TXEVT</strong></td>
<td>0</td>
<td>Event Controls&#xFF1A;                                                                                                                       If this bit is 1&#xFF0C;Bumblebee core will trigger a single-cycle pulse signal tx_evt as event signal.</td>
</tr>
</tbody>
</table>
<p>&#xF06E;This bit will be automatically reset to 0 in the next cycle when it becomes 1.
&#xF06E;No response, when this bit is 0.
Reset default value is 0. |
| <strong>Reserved</strong> | 31:1   | Reserved 0                                            |</p>
<h3 id="7515-wfe"><strong>7.5.15. wfe</strong><div id="7-5-15"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core customized CSR wfe Control whether the processor can be awaken by interrupt or event. See chapter 8.2.3 for more information.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The format of wfe register is shown in Table 7-16.</p>
<p>&#x200B;                                                        <strong><center>Table 7-16 wfe register</center></strong></p>
<table>
<thead>
<tr>
<th><strong>Field</strong></th>
<th><strong>Bit</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>WFE</strong></td>
<td>0</td>
<td>Control whether the processor can be awakened by interrupt or event.                                                         0: The processor can be awakened by interrupt and NMI in sleep mode.                                                  1&#xFF1A;The processor can be awakened by event and NMI in sleep mode. Reset default value is o</td>
</tr>
<tr>
<td><strong>Reserved</strong></td>
<td>31:1</td>
<td>Reserved 0</td>
</tr>
</tbody>
</table>
<h1 id="8-8bumblebee-low-power-mechanism"><strong>8. 8.Bumblebee Low-Power Mechanism</strong><div id="8"></div></h1>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core can support sleep mode for lower static power consumption.</p>
<h2 id="81-enter-the-sleep-mode"><strong>8.1. Enter the Sleep Mode</strong><div id="8-1"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Bumblebee Core can enter sleep mode by executing the WFI instruction. When the core executes the WFI instruction, it will perform following operations&#x201D;</p>
<ul>
<li>Stop executing the current instruction stream immediately.</li>
<li>Waiting for the core to complete any outstanding transactions, such as fetching instructions, load or store operations, to ensure that all the transactions sent to the bus are completed;<ul>
<li>Note: if a memory access error exception occurs while waiting for a bus operation to complete, the core will enter the exception handling mode rather than sleep mode.</li>
</ul>
</li>
<li>When all of the outstanding transactions are completed, the core safely enters an idle state, which is referred to as the sleep mode.</li>
<li>When entered the sleep mode:<ul>
<li>The clocks of the main units inside the Bumblebee Core will be gated off to save static power consumption;</li>
<li>The output signal core_wfi_mode of the Bumblebee Core will be asserted to indicate that this core is in the sleep mode after executing the WFI instruction;</li>
<li>The output signal core_sleep_value of the Bumblebee Core will output the value of the CSR register sleepvalue (Note: this signal is valid only when the core_wfi_mode is asserted; if the signal core_wfi_mode is 0, then the value of core_sleeep_value must be 0). The software can indicate different sleep modes (0 or 1) by configuring the CSR register sleepvalue in advance. Note:<ul>
<li>The Bumblebee Core behaves exactly the same for different sleep modes. These sleep modes only provide different controlling scheme for the Power Management Unit (PMU) at the SoC system level.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="82-exit-the-sleep-mode"><strong>8.2. Exit the Sleep Mode</strong><div id="8-2"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The key points of the Bumblebee Core exiting the sleep mode are as follows:</p>
<ul>
<li>The output signal core_wfi_mode of the Bumblebee Core is cleared to 0.</li>
<li>The Bumblebee Core can be woken up in four ways:<ul>
<li>NMI</li>
<li>Interrupt</li>
<li>Event</li>
<li>Debug request</li>
</ul>
</li>
</ul>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;These will be described in detail below.</p>
<h3 id="821-wake-up-by-nmi"><strong>8.2.1. Wake UP by NMI</strong><div id="8-2-1"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;NMI can always wake up the core. When the core detects a rising edge of the input signal nmi, the core is woken up and jumps to the NMI service routine.</p>
<h3 id="822-wake-up-by-interrupt"><strong>8.2.2. Wake Up by Interrupt</strong><div id="8-2-2"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Interrupts can wake up the core as well&#xFF1A;</p>
<ul>
<li>If the value of wfe.WFE is set to 0, then&#xFF1A;<ul>
<li>If the mstatus.MIE field is set to 1 (indicating that the global interrupt is enabled)&#xFF1A;<ul>
<li>When the ECLIC has sent the interrupt selected by the arbitration of external interrupts to the processor core, the core will be woken up and jump to the interrupt service routine.</li>
</ul>
</li>
<li>If the mstatus.MIE is set to 0 (indicating that the global interrupt is disabled):<ul>
<li>When the ECLIC has sent the interrupt selected by the arbitration of external interrupts to the processor core, the core will be woken up and continue to execute the previous instruction instead of jumping to the interrupt service routine.</li>
</ul>
</li>
</ul>
</li>
<li>If the value of wfe.WFE is set to 1, the core will be waited for an event to wake up. Please see the detailed description in the next section.</li>
</ul>
<h3 id="823-wake-up-by-event"><strong>8.2.3. Wake Up by Event</strong><div id="8-2-3"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Event can wake up the processor core when the following conditions are met:</p>
<ul>
<li>If the value of wfe.WFE is set to 1, then:&#xFF1A;<ul>
<li>When the core detects that the input signal rx_evt (called the event signal) is asserted, the core will be woken up and continue to execute the previously interrupted instruction stream (instead of entering the interrupt service routine).&#x3002;</li>
</ul>
</li>
</ul>
<h3 id="824-wake-up-by-debug-request"><strong>8.2.4. Wake Up by Debug Request</strong><div id="8-2-4"></div></h3>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;Debug requests can always wake up the core. If the debugger is connected, it will also wake up the core and enter the debug mode.</p>
<h2 id="83-wait-for-interrupt-mechanism"><strong>8.3. Wait for Interrupt Mechanism</strong><div id="8-3"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Wait for Interrupt mechanism refers to make the core enter the sleep mode, and the core keeps waiting for an interrupt to wake up. When the core wakes up, it jumps to the corresponding interrupt service routine.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As described in Section 8.1 and Section 8.2, the Wait for Interrupt mechanism can be implemented by executing the WFI instruction with setting the value of mstatus.MIE to 1.</p>
<h2 id="84-wait-for-event-mechanism"><strong>8.4. Wait for Event Mechanism</strong><div id="8-4"></div></h2>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;The Wait for Event mechanism refers to make the core enter the sleep mode, and the core keeps waiting for an interrupt to wake up. When the core wakes up, it continues to execute the previously interrupted instruction stream instead of jumping to the corresponding interrupt service routine.</p>
<p>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;As mentioned in Section 8.1 and Section 8.2, the Wait for Event mechanism can be implemented by executing the WFI instruction combined with the following sequence of instructions:</p>
<pre><code>First step&#xFF1A;set the value of wfe.WFE to 1
Second step&#xFF1A;execute the WFI instruction. The core will stay in the sleep mode until an event or NMI wakes it up.
Third step&#xFF1A;restore the value of wfe.WFE to 0.
</code></pre><footer class="page-footer"><span class="copyright">Copyright &#xA9; nuclei.com 2019 all right reserved&#xFF0C;powered by Gitbook</span><span class="footer-modification">&#x8BE5;&#x6587;&#x4EF6;&#x4E0A;&#x4F20;&#x65F6;&#x95F4;&#xFF1A;
2019-09-05 13:57:31
</span></footer>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                
                <a href="./#1-1" class="navigation navigation-next navigation-unique" aria-label="Next page: 1.1.    Introduction of the RISC-V Instruction Set Architecture">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"1.    Introduction of the Instruction Set and CSRs of the Bumblebee Core","level":"1.1","depth":1,"next":{"title":"1.1.    Introduction of the RISC-V Instruction Set Architecture","level":"1.1.1","depth":2,"anchor":"#1-1","path":"README.md","ref":"README.md#1-1","articles":[]},"dir":"ltr"},"config":{"plugins":["disqus","advanced-emoji","expandable-chapters-small","splitter","back-to-top-button","chapter-fold","sharing-plus","tbfed-pagefooter","livereload"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright &copy nuclei.com 2019","modify_label":"该文件上传时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"chapter-fold":{},"disqus":{"useIdentifier":false,"shortName":"gitbookuse"},"livereload":{},"splitter":{},"search":{},"sharing-plus":{"qq":false,"all":["facebook","google","twitter","instapaper","linkedin","pocket","stumbleupon"],"douban":false,"facebook":true,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":true,"google":false,"viber":false,"stumbleupon":false,"qzone":false,"linkedin":false},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"back-to-top-button":{},"expandable-chapters-small":{},"advanced-emoji":{"embedEmojis":false},"sharing":{"facebook":false,"twitter":false,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":[]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"gitbook tutorial","links":{"gitbook":false,"sharing":{"google":false,"facebook":false,"twitter":false,"all":false}},"gitbook":"*","description":"nuclei book"},"file":{"path":"README.md","mtime":"2019-09-05T05:57:31.423Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-09-05T06:04:54.191Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/URI.js/1.16.1/URI.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-disqus/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-chapter-fold/chapter-fold.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing-plus/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

