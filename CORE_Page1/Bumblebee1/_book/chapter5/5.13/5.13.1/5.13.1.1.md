### **5.13.1. 非向量处理模式**



#### **5.13.1.1 非向量处理模式的特点和延迟**

如果被配置成为非向量处理模式，则该中断被处理器内核响应后，处理器会直接跳入到所有非向量中断共享的入口地址，该入口地址可以通过软件进行设置：

- 如果配置CSR寄存器mtvt2的最低位为0（上电复位默认值），则所有非向量中断共享的入口地址由CSR寄存器mtvec的值（忽略最低2位的值）指定。由于mtvec寄存器的值也指定异常的入口地址，因此，意味着在这种情况下，异常和所有非向量中断共享入口地址。
- 如果配置CSR寄存器mtvt2的最低位为1，则所有非向量中断共享的入口地址由CSR寄存器mtvt2的值（忽略最低2位的值）指定。为了让中断以尽可能快的速度被响应和处理，推荐将CSR寄存器mtvt2的最低位设置为1，即，由mtvt2指定一个独立的入口地址供所有非向量中断专用，和异常的入口地址（由mtvec的值指定）彻底分开。
- 在进入所有非向量中断共享的入口地址之后，处理器会开始执行一段共有的软件代码，如图 5-9中所示的例子，这段软件代码内容通常如下：
- 首先保存CSR寄存器mepc、mcause、msubm入堆栈。保存这几个CSR寄存器是为了保证后续的中断嵌套能够功能正确，因为新的中断响应会重新覆盖mepc、mcause、msubm的值，因此需要将它们先保存入堆栈。
- 保存若干通用寄存器（处理器的上下文）入堆栈。
- 然后执行一条特殊的指令“csrrw ra， CSR_JALMNXTI， ra”。如果没有中断在等待（Pending），则该指令相当于是个Nop指令不做任何操作；如果有中断在等待（Pending），执行该指令后处理器会：
  - 直接跳入该中断的向量入口（Vector Table Entry）存储的目标地址，即该中断源的中断服务程序（Interrupt Service Routine，ISR）中去。
  - 在跳入中断服务程序的同时，硬件也会同时打开中断的全局使能，即，设置mstatus寄存器的MIE域为1。打开中断全局使能后，新的中断便可以被响应，从而达到中断嵌套的效果。
  - 在跳入中断服务程序的同时，“csrrw ra， CSR_JALMNXTI， ra”指令还会达到JAL（Jump and Link）的效果，硬件同时更新Link寄存器的值为该指令的PC自身作为函数调用的返回地址。因此，从中断服务程序函数返回后会回到该“csrrw ra， CSR_JALMNXTI， ra”指令重新执行，重新判断是否还有中断在等待（Pending），从而达到中断咬尾的效果。
  - 在中断服务程序的结尾处同样需要添加对应的恢复上下文出栈操作。并且在CSR寄存器mepc、mcause、msubm出堆栈之前，需要将中断全局使能再次关闭，以保证mepc、mcause、msubm恢复操作的原子性（不被新的中断所打断）。



![](5.13.1.1.assets/16.png)

​                                                **<center>图 5-9 中断的非向量处理模式示例（总是支持嵌套）</center>**



由于非向量处理模式时处理器在跳到中断服务程序之前需要先执行一段共有的软件代码进行上下文的保存，因此，从中断源拉高到处理器开始执行中断服务程序中的第一条指令，需要经历以下几个方面的时钟周期开销：

- 处理器内核响应中断后进行跳转的开销。理想情况下约4个时钟周期。
- 处理器内核保存CSR寄存器mepc、mcause、msubm入堆栈的开销。
- 处理器内核保存上下文所花费的周期开销。如果是RV32E的架构，则需要保存8个通用寄存器，如果是RV32I的架构，则需要保存16个通用寄存器。
- 处理器内核跳转到中断服务程序（Interrupt Service Routine，ISR）中去的开销。理想情况下约需要5个时钟周期。

